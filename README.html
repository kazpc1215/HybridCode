<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="github.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="hybridcode">HybridCode</h1>
<p>衝突・破壊をとりいれたN体計算 Saturnを使う場合は&quot;ISOYAforSaturn&quot;</p>
<p>作成者：磯谷和秀</p>
<h1 id="ディレクトリ構成">1. ディレクトリ構成</h1>
<h2 id="source">source/</h2>
<p>ソースコードとMakefile</p>
<h2 id="data">data/</h2>
<p>データ保管</p>
<h2 id="image">image/</h2>
<p>画像保管</p>
<h2 id="log">log/</h2>
<p>ログ保管（最新版では「data/」中にlog.txtとして保存している）</p>
<h1 id="source内のファイル概要">2.「source/」内のファイル概要</h1>
<h2 id="makefile">Makefile</h2>
<p>コンパイル用のMakefile</p>
<p>コンパイルがうまくいくと、実行ファイルの名前の入力待ちになる</p>
<p>天文台のXC50を使う際には、ジョブを投げる用のシェルスクリプトを生成することもできる</p>
<h2 id="hybrid.h">hybrid.h</h2>
<p>ヘッダーファイル</p>
<p>パラメータは基本ここでいじる</p>
<h2 id="func.h">func.h</h2>
<p>関数の宣言用ヘッダー</p>
<h2 id="hybrid_main.c">hybrid_main.c</h2>
<p>メインファイル</p>
<h2 id="acc.c">acc.c</h2>
<p>加速度や加加速度計算</p>
<h2 id="collision.c">collision.c</h2>
<p>衝突判定、衝突前後の操作</p>
<h2 id="energy.c">energy.c</h2>
<p>エネルギー計算</p>
<h2 id="heapsort.c">heapsort.c</h2>
<p>ヒープソート（階層化タイムステップを導入する際に必要）</p>
<h2 id="massflux.c">massflux.c</h2>
<p>衝突・破壊の際の定常質量フラックス（Kobayashi &amp; Tanaka, 2010）を計算</p>
<h2 id="neighbor.c">neighbor.c</h2>
<p>近傍トレーサーの探索、面密度と平均相対速度の計算</p>
<h2 id="orbital_elements.c">orbital_elements.c</h2>
<p>初期軌道要素の設定（or 初期位置の設定）、軌道要素計算</p>
<h2 id="sfmt.c">SFMT.c</h2>
<p>メルセンヌ・ツイスタ法による乱数生成</p>
<h2 id="sfmtdir">SFMTdir/</h2>
<p>メルセンヌ・ツイスタ法用のヘッダーが入ったディレクトリ</p>
<h2 id="sub.c">sub.c</h2>
<p>一行でかけるような細々した関数</p>
<h2 id="timestep.c">timestep.c</h2>
<p>タイムステップ計算</p>
<h2 id="qsub_depend.sh">qsub_depend.sh</h2>
<p>天文台のXC50にて、ジョブを投げるシェルスクリプト</p>
<h1 id="ソースコードの詳細">3.ソースコードの詳細</h1>
<h2 id="hybrid.h-1">hybrid.h</h2>
<div class="sourceCode"><pre class="sourceCode c:hybrid.h"><code class="sourceCode c"><span class="pp">#ifndef INCLUDED_hybrid_H  </span><span class="co">//include-guard</span>
<span class="pp">#define INCLUDED_hybrid_H  </span><span class="co">//include-guard</span>
.
.
.
<span class="pp">#endif </span><span class="co">//include-guard</span></code></pre></div>
<p>このヘッダーファイルを複数のファイルで読み込む場合、一度読んだものは再度読まないようにする。</p>
<div class="sourceCode"><pre class="sourceCode c:hybrid.h"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;math.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;time.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;mpi.h&gt;</span>
<span class="pp">#include </span><span class="im">&quot;SFMTdir/SFMT.h&quot;</span>

<span class="pp">#ifdef _OPENMP</span>
<span class="pp">#include </span><span class="im">&lt;omp.h&gt;</span>
<span class="pp">#define OMP_SCHEDULE static</span>
<span class="pp">#endif</span></code></pre></div>
<p>stdlib.h, stdio.h, math.hの説明は省略。</p>
<p>sys/stat.h : 時間計測に使う。</p>
<p>time.h : 時間計測に使う。</p>
<p>stdbool.h : Boolean型の関数やtrue(==1), false(==0)を使う。</p>
<p>mpi.h : MPI並列に使う。Macには標準では入っていないので、Macportsとかで入れ、コンパイルオプションでライブラリなどを指定する。天文台のXC50ではコンパイルオプションはいらない。</p>
<p>SFMTdir/SFMT.h : メルセンヌ・ツイスタ法を使う。</p>
<p>omp.h : OpenMP並列に使う。gccではコンパイルオプションに-fopenmpをつける。このオプションがない場合、_OPENMPは定義されないため、インクルードしないようにしている。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#if __GNUC__ == 7</span>
<span class="pp">#define CONST const</span>
<span class="pp">#define ALWAYS_INLINE __attribute__((always_inline))</span>
<span class="pp">#else</span>
<span class="pp">#define CONST</span>
<span class="pp">#define ALWAYS_INLINE</span>
<span class="pp">#endif</span></code></pre></div>
<p>関数の引数としてポインタを渡しつつもそれを変更しない場合（配列とか）、型の前にconstをつけることが推奨されているが、gccがver4より古いときにエラーになるので、CONSTというマクロを変わりに書いている。この例ではgccのver7の場合のみCONSTをconstとして定義している。</p>
<p>さらに、gccでは関数のインライン展開を強制的に行いたいときに、<strong>attribute</strong>((always_inline))を関数名の前につけるが、これも古いversionでは使えないため、ALWAYS_INLINEというマクロを変わりに書いている。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#define DIRECTORY ../data/Ntr1E2_t1E8_dtlog_Mtot3E-5_Mmax5E-15_ecc1E-1_nofrag_acc/  </span><span class="co">//ディレクトリ.</span>
<span class="pp">#define SUBDIRECTORY rand  </span><span class="co">//子ディレクトリ. rand%02d</span></code></pre></div>
<p>データを書き出すファイルを置くディレクトリを指定する。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#define STR_(str) #str</span>
<span class="pp">#define STR(str) STR_(str)</span></code></pre></div>
<p>マクロを文字列に変換するマクロ。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#define INV_3 0.33333333333333333333</span></code></pre></div>
<p>1/3を定義。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#ifndef EXTERN</span>
<span class="pp">#define EXTERN extern</span>
<span class="pp">#endif</span></code></pre></div>
<p>グローバル変数をこのヘッダーで宣言する際に、externを型の前につける。そして、グローバル変数を定義するファイル（hybrid_main.c）にてこのヘッダーを読み込む前にEXTERNマクロを定義するようにする。その他のファイルではEXTERNを定義しないようにしているため、定義が重複しない。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//////////////////////////////////////////////////</span>
<span class="pp">#define N_tr 100  </span><span class="co">//初期のトレーサーの数.</span>
<span class="pp">#define N_p 1  </span><span class="co">//初期の原始惑星の数.</span>
<span class="pp">#define ECC_RATIO 10.0  </span><span class="co">//ecc=0.01の何倍か. inc=ecc/2.</span>
<span class="pp">#define STEP_INTERVAL 5.0E5  </span><span class="co">//何ステップごとに標準出力するか.</span>
<span class="co">//#define BREAK_TIME 100.0  //4h = 14400sec, 12h = 43200sec.</span>
<span class="pp">#define BREAK_TIME 14100.0  </span><span class="co">//4h = 14400sec, 12h = 43200sec.</span>
<span class="co">//#define BREAK_TIME 42900.0  //4h = 14400sec, 12h = 43200sec.</span>

<span class="pp">#define RAYLEIGH_DISTRIBUTION true  </span><span class="co">//離心率や軌道傾斜角の分布 true : Rayleigh, false : v_relが軌道長半径によらず一定.</span>

<span class="pp">#define FRAGMENTATION false  </span><span class="co">//破壊 近傍粒子探索と質量フラックス計算.</span>
<span class="pp">#define COLLISION true  </span><span class="co">//衝突.</span>
<span class="pp">#if COLLISION</span>
<span class="pp">#define COALESCENCE true  </span><span class="co">//衝突後に合体.</span>
<span class="pp">#else</span>
<span class="co">//#define SOFTENING true  //衝突しないようソフトニング.</span>
<span class="pp">#endif</span></code></pre></div>
<p>計算パラメータ。true, falseはそれぞれ1, 0を意味しており、各関数の中で#ifを使って場合分けしている。</p>
<p>BREAK_TIMEは実行する実時間（秒）。XC50では一回の実行時間が制限されているため。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">EXTERN <span class="dt">int</span> global_n;  <span class="co">//グローバル変数.</span>
EXTERN <span class="dt">int</span> global_n_p;
EXTERN <span class="dt">int</span> global_myid;
EXTERN sfmt_t sfmt;
EXTERN FILE *fplog;

<span class="co">//////////////////////////////////////////////////</span></code></pre></div>
<p>グローバル変数の宣言。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//////////////////////////////////////////////////</span>
<span class="pp">#define ENERGY_FILE true  </span><span class="co">//エネルギー計算&amp;ファイル作成.</span>
<span class="pp">#define ORBITALELEMENTS_FILE true  </span><span class="co">//軌道要素計算&amp;ファイル作成.</span>
<span class="pp">#define POSI_VELO_FILE true  </span><span class="co">//位置速度ファイル作成.</span>
<span class="pp">#define COLLISION_FILE true  </span><span class="co">//衝突直前の位置速度ファイル作成.</span>
<span class="pp">#define TRACERLIST_FILE true  </span><span class="co">//トレーサーリストのファイル作成.</span>
<span class="pp">#define EXECUTION_TIME true  </span><span class="co">//mainの実行時間測定.</span>
<span class="pp">#define EXECUTION_TIME_FUNC false  </span><span class="co">//mainかつ関数ごとの実行時間測定.</span>
<span class="pp">#if EXECUTION_TIME</span>
<span class="pp">#include </span><span class="im">&lt;sys/time.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;sys/resource.h&gt;</span>
<span class="pp">#endif</span>
<span class="co">//////////////////////////////////////////////////</span></code></pre></div>
<p>true, falseはそれぞれ1, 0を意味しており、各関数の中で#ifを使って場合分けしている。</p>
<p>実行時間を図る場合、実時間についてはsystem/time.h、CPU時間とシステム時間についてはsys/resource.hが必要。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//////////////////////////////////////////////////</span>
<span class="pp">#define INTERACTION_ALL false  </span><span class="co">//全粒子同士の重力相互作用.</span>
<span class="pp">#define INTERACTION_PLANET_TRACER true  </span><span class="co">//惑星とトレーサー間の相互作用.</span>
<span class="pp">#define INTERACTION_TEST_PARTICLE false  </span><span class="co">//トレーサーをテスト粒子として扱う.</span>
<span class="pp">#define INDIRECT_TERM true  </span><span class="co">//中心星が動く効果を補正.</span>
<span class="pp">#define EJECTION false  </span><span class="co">//初期に破片（トレーサー）を放出する.</span>
<span class="pp">#define ORBITING_SMALL_PARTICLE true  </span><span class="co">//初期に微惑星をケプラー運動させておく.</span>
<span class="pp">#define ELIMINATE_PARTICLE false  </span><span class="co">//太陽に飲みこまれるか系外へ出て行くかで粒子を消す.</span>
<span class="co">//////////////////////////////////////////////////</span></code></pre></div>
<p>true, falseはそれぞれ1, 0を意味しており、各関数の中で#ifを使って場合分けしている。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//////////////////////////////////////////////////</span>
<span class="co">//#define G 1.0  //重力定数.</span>
<span class="co">//#define M_0 1.0  //主星の質量.</span>
<span class="pp">#if SOFTENING</span>
<span class="pp">#define EPSILON 5.21495378928615e-05   </span><span class="co">//ソフトニングパラメーター.</span>
<span class="pp">#endif</span>
<span class="pp">#define ETA 1.0E-2  </span><span class="co">//刻み幅調整.</span>
<span class="pp">#define ITE_MAX 2  </span><span class="co">//イテレーション回数（修正子計算の回数はITE_MAX+1）.</span>
<span class="co">//////////////////////////////////////////////////</span></code></pre></div>
<p>エルミート法で必要なパラメータ。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#if ELIMINATE_PARTICLE</span>
<span class="co">//////////////////////////////////////////////////</span>
<span class="pp">#define SOLAR_RADIUS 0.00465040106951872  </span><span class="co">//[AU] 6.957E10/1.496E13.</span>
<span class="pp">#define SOLAR_SYSTEM_LIMIT 100.0  </span><span class="co">//[AU]</span>
<span class="co">//////////////////////////////////////////////////</span>
<span class="pp">#endif</span></code></pre></div>
<p>太陽に飲みこまれるか系外へ出て行くかで粒子を消す場合に必要なパラメータ。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//////////////////////////////////////////////////</span>
<span class="pp">#define PLANET_MASS 3.0E-6  </span><span class="co">//地球質量M_E.</span>
<span class="pp">#define PLANET_AXIS 1.0  </span><span class="co">//[AU].</span>
<span class="pp">#define PLANET_ECC (0.01*ECC_RATIO)</span>
<span class="pp">#define PLANET_INC (PLANET_ECC*0.5)</span>
<span class="pp">#define PLANET_DENSITY 3.0  </span><span class="co">//[g/cc].</span>
<span class="co">/*</span>
<span class="co">Earth Mean Orbital Elements (J2000)</span>
<span class="co">Semimajor axis (AU)                  1.00000011</span>
<span class="co">Orbital eccentricity                 0.01671022</span>
<span class="co">Orbital inclination (deg)            0.00005</span>
<span class="co">Longitude of ascending node (deg)  -11.26064</span>
<span class="co">Longitude of perihelion (deg)      102.94719</span>
<span class="co">Mean Longitude (deg)               100.46435</span>
<span class="co">*/</span>
<span class="co">//////////////////////////////////////////////////</span></code></pre></div>
<p>惑星の初期パラメータ。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#if N_tr != 0</span>
<span class="co">//////////////////////////////////////////////////</span>
<span class="pp">#define M_TOT (3.0E-7*N_p)  </span><span class="co">//0.1M_E * N_p  //トレーサーの総質量.</span></code></pre></div>
<p>トレーサーの総質量。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#if EJECTION</span>
<span class="pp">#define PLANET_OF_EJECTION 1</span>
<span class="pp">#define EJECTION_CONE_ANGLE M_PI/180.0*30.0  </span><span class="co">//30度.</span>
<span class="pp">#endif</span>

<span class="pp">#if ORBITING_SMALL_PARTICLE</span>
<span class="pp">#define ECC_RMS (0.01*ECC_RATIO)  </span><span class="co">//トレーサーの離心率の二乗平均平方根.  //Rayleigh分布.</span>
<span class="pp">#define INC_RMS (ECC_RMS*0.5)  </span><span class="co">//トレーサーの軌道傾斜角の二乗平均平方根.  //Rayleigh分布.</span>
<span class="pp">#define DELTA_HILL 10.0  </span><span class="co">//惑星を「相互」ヒル半径の何倍離すか（軌道長半径）.</span>
<span class="pp">#define SEPARATE_HILL 5.0  </span><span class="co">//初期に惑星とトレーサーをヒル半径の何倍以上離すか（相対距離）.</span>
<span class="pp">#endif</span></code></pre></div>
<p>トレーサーの初期パラメータ。EJECTION（破片として放出）かORBITATING_SMALL_PARTICLE（軌道上を運動）を上で選ぶ。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#if FRAGMENTATION</span>
<span class="co">/* t_fragcheck : 初項 DT_FRAGCHECK，公比 GEOMETRIC_RATIO_FRAG の等比数列 */</span>
<span class="pp">#define DT_FRAGCHECK 2.0*M_PI*0.1  </span><span class="co">//0.1yr</span>
<span class="pp">#define GEOMETRIC_RATIO_FRAG pow(10.0,1.0/8.0) </span><span class="co">//10**(1/8)</span>
<span class="pp">#define DELTA_R 0.01  </span><span class="co">//Hill 近傍粒子探索用.</span>
<span class="pp">#define DELTA_THETA 0.125*M_PI  </span><span class="co">//近傍粒子探索用.</span>
<span class="co">//#define DELTA_THETA 1.0*M_PI  //近傍粒子探索用.</span>
<span class="pp">#define NEIGHBOR_MAX 200  </span><span class="co">//近傍粒子リスト配列の最大値.</span>
<span class="pp">#define RHO 3.0  </span><span class="co">// [g/cc]  微惑星の物質密度.</span>
<span class="pp">#define EPSILON_FRAG 0.2</span>
<span class="pp">#define B_FRAG (5.0/3.0)</span>
<span class="pp">#define Q_0_FRAG 9.5E8 </span><span class="co">// [erg/g]  Q_D = Q_0*(rho/3[g/cc])^0.55*(m/10^21[g])^p</span>
<span class="pp">#define P_FRAG 0.453</span>
<span class="pp">#define XI 0.01 </span><span class="co">//面密度減少タイムスケールを自身のXI倍間隔で更新する.</span>
<span class="pp">#define M_MAX 5.00E-15  </span><span class="co">//最大微惑星質量. 1E19 g ~10kmサイズ.</span>
<span class="co">//#define M_MAX 5.00E-18  //最大微惑星質量. 1E16 g ~1kmサイズ.</span>
<span class="pp">#endif  </span><span class="co">/*FRAGMENTATION*/</span>
<span class="co">//////////////////////////////////////////////////</span>
<span class="pp">#endif  </span><span class="co">/*N_tr != 0*/</span></code></pre></div>
<p>破壊計算のパラメータ。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">//////////////////////////////////////////////////</span>
<span class="pp">#define T_MAX (2.0*M_PI*1.0E8)  </span><span class="co">//10^8yr 全計算時間.</span>
<span class="pp">#define DT_LOG true  </span><span class="co">//true: t_eneをlogでとる. false: t_eneをlinearでとる.</span>

<span class="co">/* linear では 初項 DT_ENE，公差 DT_ENE の等差数列 */</span>
<span class="pp">#define DT_ENE (2.0*M_PI*1.0E-1)  </span><span class="co">//dt_ene = 0.1yr</span>

<span class="pp">#if DT_LOG</span>
<span class="co">/* log では 初項 DT_ENE，公比 GEOMETRIC_RATIO の等比数列 */</span>
<span class="pp">#define GEOMETRIC_RATIO pow(10.0,1.0/8.0) </span><span class="co">//10**(1/8)</span>
<span class="pp">#define GEOMETRIC_RATIO_LONGTERM pow(10.0,1.0/128.0) </span><span class="co">//10**(1/128) 10^6yrを超える時用.</span>
<span class="pp">#endif</span>
<span class="co">//////////////////////////////////////////////////</span></code></pre></div>
<p>何年分計算するかを設定。重力定数を1とし、質量を太陽質量、距離を1AUで規格化すると、時間は1/2<span class="math inline"><em>π</em></span>年に規格化される。そのため、「年」を設定する場合には2<span class="math inline"><em>π</em></span>を掛ける。</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> orbital_elements{
  <span class="dt">char</span> name[<span class="dv">30</span>];  <span class="co">//名前（番号.</span>
  <span class="dt">double</span> ecc;  <span class="co">//離心率.</span>
  <span class="dt">double</span> axis;  <span class="co">//軌道長半径.</span>
  <span class="dt">double</span> u;  <span class="co">//離心近点離角.</span>
  <span class="dt">double</span> inc;  <span class="co">//軌道傾斜角.</span>
  <span class="dt">double</span> Omega;  <span class="co">//昇交点経度.</span>
  <span class="dt">double</span> omega;  <span class="co">//近点引数.</span>
  <span class="dt">double</span> r_h;  <span class="co">//ヒル半径.</span>
  <span class="dt">double</span> radius;  <span class="co">//物理半径.</span>
  <span class="dt">double</span> mass;  <span class="co">//質量.</span>
  <span class="dt">int</span> orinum;  <span class="co">//初期の番号.</span>
};


<span class="pp">#if FRAGMENTATION</span>
<span class="kw">struct</span> fragmentation{
  <span class="dt">int</span> neighborlist[NEIGHBOR_MAX+<span class="dv">1</span>];  <span class="co">//近傍粒子リスト.</span>
  <span class="dt">int</span> neighbornumber;  <span class="co">//近傍粒子の個数</span>
  <span class="dt">double</span> delta_r_out;  <span class="co">//扇型外側.</span>
  <span class="dt">double</span> delta_r_in;  <span class="co">//扇型内側.</span>
  <span class="dt">double</span> sigma;  <span class="co">//表面密度.</span>
  <span class="dt">double</span> n_s;  <span class="co">//表面数密度.</span>
  <span class="dt">double</span> v_ave;  <span class="co">//領域内での平均速度.</span>
  <span class="dt">double</span> flux;  <span class="co">//質量フラックス.</span>
  <span class="dt">double</span> dt_frag;  <span class="co">//統計的計算の粒子ごとのタイムステップ.</span>
  <span class="dt">double</span> t_frag;  <span class="co">//統計的計算の粒子ごとの時間.</span>
  <span class="dt">int</span> fragtimes;  <span class="co">//何回統計的計算をしているか.</span>
};


<span class="kw">struct</span> parameter{
  <span class="dt">double</span> s_1;
  <span class="dt">double</span> s_2;
  <span class="dt">double</span> s_3;
  <span class="dt">double</span> alpha;
  <span class="dt">double</span> h_0;
  <span class="dt">double</span> Q_D;
};
<span class="pp">#endif</span>


<span class="pp">#if EXECUTION_TIME</span>
<span class="kw">struct</span> execution_time{
  <span class="dt">double</span> Energy[<span class="dv">3</span>];  <span class="co">//[0]: real time, [1]: user(cpu) time, [2]: system time</span>
  <span class="dt">double</span> Orbital_Elements[<span class="dv">3</span>];
  <span class="dt">double</span> Predictor[<span class="dv">3</span>];
  <span class="dt">double</span> Corrector[<span class="dv">3</span>];
  <span class="dt">double</span> Iteration[<span class="dv">3</span>];
  <span class="dt">double</span> Collision_Judgement[<span class="dv">3</span>];
  <span class="dt">double</span> Fragmentation[<span class="dv">3</span>];
};
EXTERN <span class="kw">struct</span> execution_time exetime;  <span class="co">//グローバル変数</span>
<span class="pp">#endif</span></code></pre></div>
<p>各構造体の宣言。</p>
<ol type="1">
<li>orbital_elements 軌道要素の構造体（粒子毎にもつので配列）。</li>
<li>fragmentation 破壊計算に必要なデータをもつ構造体（トレーサー毎にもつので配列）。</li>
<li>parameter 破壊計算のパラメータの構造体。</li>
<li>execution_time 実行開始からの時間をもつ構造体。</li>
</ol>
<h2 id="func.h-1">func.h</h2>
<p>インクルードガードあり。</p>
<p>関数の宣言が主だが、複数のファイルにある関数からよく呼ばれるような簡単な関数を、インライン関数として定義する。</p>
<div class="sourceCode"><pre class="sourceCode c:func.h"><code class="sourceCode c"><span class="co">/*x_i,v_iの内積*/</span>
<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">double</span> InnerProduct(<span class="dt">int</span> i, CONST <span class="dt">double</span> x[][<span class="dv">4</span>], CONST <span class="dt">double</span> v[][<span class="dv">4</span>]){
  <span class="cf">return</span> x[i][<span class="dv">1</span>]*v[i][<span class="dv">1</span>] + x[i][<span class="dv">2</span>]*v[i][<span class="dv">2</span>] + x[i][<span class="dv">3</span>]*v[i][<span class="dv">3</span>];
}

<span class="co">/*中心星からの距離*/</span>
<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">double</span> RadiusFromCenter(<span class="dt">int</span> i, CONST <span class="dt">double</span> x[][<span class="dv">4</span>]){
  <span class="cf">return</span> sqrt(x[i][<span class="dv">1</span>]*x[i][<span class="dv">1</span>] + x[i][<span class="dv">2</span>]*x[i][<span class="dv">2</span>] + x[i][<span class="dv">3</span>]*x[i][<span class="dv">3</span>]);
}

<span class="co">/*速度の2乗*/</span>
<span class="co">static inline double SquareOfVelocity(int i, CONST double v[][4]){</span>
<span class="co">  return v[i][1]*v[i][1] + v[i][2]*v[i][2] + v[i][3]*v[i][3];</span>
<span class="co">}</span>

<span class="co">/*相対距離*/</span>
<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">double</span> RelativeDistance(<span class="dt">int</span> i, <span class="dt">int</span> j, CONST <span class="dt">double</span> x[][<span class="dv">4</span>]){
  <span class="cf">return</span> sqrt((x[j][<span class="dv">1</span>] - x[i][<span class="dv">1</span>])*(x[j][<span class="dv">1</span>] - x[i][<span class="dv">1</span>]) + (x[j][<span class="dv">2</span>] - x[i][<span class="dv">2</span>])*(x[j][<span class="dv">2</span>] - x[i][<span class="dv">2</span>]) + (x[j][<span class="dv">3</span>] - x[i][<span class="dv">3</span>])*(x[j][<span class="dv">3</span>] - x[i][<span class="dv">3</span>]));
}

<span class="co">/*相対速度の2乗*/</span>
<span class="co">static inline double SquareOfRelativeVelocity(int i, int j, CONST double v[][4]){</span>
<span class="co">  return (v[j][1] - v[i][1])*(v[j][1] - v[i][1]) + (v[j][2] - v[i][2])*(v[j][2] - v[i][2]) + (v[j][3] - v[i][3])*(v[j][3] - v[i][3]);</span>
<span class="co">}</span>

<span class="co">/*x_ij, v_ijの内積*/</span>
<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">double</span> RelativeInnerProduct(<span class="dt">int</span> i, <span class="dt">int</span> j, CONST <span class="dt">double</span> x[][<span class="dv">4</span>], CONST <span class="dt">double</span> v[][<span class="dv">4</span>]){
  <span class="cf">return</span> (x[j][<span class="dv">1</span>] - x[i][<span class="dv">1</span>])*(v[j][<span class="dv">1</span>] - v[i][<span class="dv">1</span>]) + (x[j][<span class="dv">2</span>] - x[i][<span class="dv">2</span>])*(v[j][<span class="dv">2</span>] - v[i][<span class="dv">2</span>]) + (x[j][<span class="dv">3</span>] - x[i][<span class="dv">3</span>])*(v[j][<span class="dv">3</span>] - v[i][<span class="dv">3</span>]);
}

<span class="co">/*Swap*/</span>
<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> Swap_double(<span class="dt">double</span> *a, <span class="dt">double</span> *b){
  <span class="dt">double</span> tmp;
  tmp = (*a);
  (*a) = (*b);
  (*b) = tmp;
  <span class="cf">return</span>;
}


<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> Swap_int(<span class="dt">int</span> *a, <span class="dt">int</span> *b){
  <span class="dt">int</span> tmp;
  tmp = (*a);
  (*a) = (*b);
  (*b) = tmp;
  <span class="cf">return</span>;
}


<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span> Min_int(<span class="dt">int</span> a, <span class="dt">int</span> b){
  <span class="cf">if</span>(a &lt; b){
    <span class="cf">return</span> a;
  }<span class="cf">else</span>{
    <span class="cf">return</span> b;
  }
}


<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span> Max_int(<span class="dt">int</span> a, <span class="dt">int</span> b){
  <span class="cf">if</span>(a &gt; b){
    <span class="cf">return</span> a;
  }<span class="cf">else</span>{
    <span class="cf">return</span> b;
  }
}


<span class="dt">static</span> <span class="kw">inline</span> <span class="dt">double</span> Cal_time(<span class="kw">struct</span> timeval time1, <span class="kw">struct</span> timeval time2){
  <span class="cf">return</span> (<span class="dt">double</span>)(time2.tv_sec - time1.tv_sec) + (<span class="dt">double</span>)(time2.tv_usec - time1.tv_usec)*<span class="fl">1.0E-6</span>;
}</code></pre></div>
<p>インライン関数。</p>
<p>内積や距離の計算や、int型とdouble型の変数の入れ替え、2つの数字の大小、実行時間計算</p>
<div class="sourceCode"><pre class="sourceCode c:func.h"><code class="sourceCode c"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> Predictor(<span class="dt">int</span> i, CONST <span class="dt">double</span> x_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> v_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> a_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> adot_0[][<span class="dv">4</span>], <span class="dt">double</span> x_p[][<span class="dv">4</span>], <span class="dt">double</span> v_p[][<span class="dv">4</span>], <span class="dt">double</span> r_p[], <span class="dt">double</span> v2_p[], <span class="dt">double</span> r_dot_v[], CONST <span class="dt">double</span> Dt[]){

  <span class="dt">int</span> k;
  <span class="dt">double</span> dt = Dt[i];

  <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){
    <span class="co">//x_p[i][k] = x_0[i][k] + v_0[i][k]*Dt[i] + a_0[i][k]*Dt[i]*Dt[i]/2.0 + adot_0[i][k]*Dt[i]*Dt[i]*Dt[i]/6.0;</span>
    <span class="co">//v_p[i][k] = v_0[i][k] + a_0[i][k]*Dt[i] + adot_0[i][k]*Dt[i]*Dt[i]/2.0;</span>

    x_p[i][k] = x_0[i][k] + dt * (v_0[i][k] + dt * <span class="fl">0.5</span> * (a_0[i][k] + adot_0[i][k] * dt * INV_3));
    v_p[i][k] = v_0[i][k] + dt * (a_0[i][k] + adot_0[i][k] * dt * <span class="fl">0.5</span>);
  }


  r_p[i] = RadiusFromCenter(i,x_p);  <span class="co">//中心星からの距離.</span>
  v2_p[i] = SquareOfVelocity(i,v_p); <span class="co">//速度の2乗.</span>
  r_dot_v[i] = InnerProduct(i,x_p,v_p);  <span class="co">//r_i,v_iの内積.</span>

  <span class="cf">return</span>;
}</code></pre></div>
<p>予測子計算（インライン関数）。</p>
<ol type="1">
<li>i i 粒子。</li>
<li>x_0[][4] 初期位置。</li>
<li>v_0[][4] 初期速度。</li>
<li>a_0[][4] 加速度。</li>
<li>adot_0[][4] 加加速度。</li>
<li>x_p[][4] 位置の予測子。</li>
<li>v_p[][4] 速度の予測子。</li>
<li>r_p[] 中心星からの距離の予測子。</li>
<li>v2_p[] 速度の予測子の大きさの2乗。</li>
<li>r_dot_v[] 位置ベクトルと速度ベクトルの内積。</li>
<li>Dt[] タイムステップ。（次のステップのシステム時間）ー（今のステップの粒子毎の時間）。</li>
</ol>
<h2 id="acc.c-1">acc.c</h2>
<div class="sourceCode"><pre class="sourceCode c:acc.c"><code class="sourceCode c"><span class="co">/*相互重力加速度*/</span>
<span class="dt">static</span> <span class="kw">inline</span> ALWAYS_INLINE <span class="dt">double</span> Acceleration_ij(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k, CONST <span class="dt">double</span> m_j, CONST <span class="dt">double</span> x_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> abs_r[]){
  <span class="dt">double</span> rij3;

<span class="pp">#ifndef EPSILON</span>
  rij3 = abs_r[j]*abs_r[j]*abs_r[j];
<span class="pp">#else</span>
  rij3 = (abs_r[j]*abs_r[j] + EPSILON*EPSILON)*sqrt(abs_r[j]*abs_r[j] + EPSILON*EPSILON);
<span class="pp">#endif</span>
  rij3 = <span class="fl">1.0</span>/rij3;

<span class="pp">#ifndef G</span>
  <span class="cf">return</span> m_j * (x_0[j][k] - x_0[i][k]) * rij3;
<span class="pp">#else</span>
  <span class="cf">return</span> G * m_j * (x_0[j][k] - x_0[i][k]) * rij3;
<span class="pp">#endif</span>
}</code></pre></div>
<p>i, j粒子間の加速度計算。 <span class="math inline">$G m_j \frac{(\vec{x}_j - \vec{x}_i)}{({r_{ij}^2 + \varepsilon^2 )}^{3/2}}$</span></p>
<ol type="1">
<li>i i 粒子。</li>
<li>j j 粒子。</li>
<li>k ベクトル3成分。</li>
<li>m_j j 粒子の質量。</li>
<li>x_0[][4] 粒子の位置x, y, zの配列。</li>
<li>abs_r[] i, j 粒子間の距離。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:acc.c"><code class="sourceCode c"><span class="co">/*相互重力加加速度*/</span>
<span class="dt">static</span> <span class="kw">inline</span> ALWAYS_INLINE <span class="dt">double</span> dAcceleration_ij(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k, CONST <span class="dt">double</span> m_j, CONST <span class="dt">double</span> x_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> v_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> r_dot_v_ij[], CONST <span class="dt">double</span> abs_r[]){
  <span class="dt">double</span> rij3;
  <span class="dt">double</span> rij5;

<span class="pp">#ifndef EPSILON</span>
  rij3 = abs_r[j]*abs_r[j]*abs_r[j];
  rij5 = rij3*abs_r[j]*abs_r[j];
<span class="pp">#else</span>
  rij3 = (abs_r[j]*abs_r[j] + EPSILON*EPSILON)*sqrt(abs_r[j]*abs_r[j] + EPSILON*EPSILON);
  rij5 = (abs_r[j]*abs_r[j] + EPSILON*EPSILON)*(abs_r[j]*abs_r[j] + EPSILON*EPSILON)*sqrt(abs_r[j]*abs_r[j] + EPSILON*EPSILON);
<span class="pp">#endif</span>
  rij3 = <span class="fl">1.0</span>/rij3;
  rij5 = <span class="fl">1.0</span>/rij5;

<span class="pp">#ifndef G</span>
  <span class="cf">return</span> m_j * ((v_0[j][k] - v_0[i][k]) * rij3 - <span class="fl">3.0</span> * r_dot_v_ij[j] * (x_0[j][k] - x_0[i][k]) * rij5);
<span class="pp">#else</span>
  <span class="cf">return</span> G * m_j * ((v_0[j][k] - v_0[i][k]) * rij3 - <span class="fl">3.0</span> * r_dot_v_ij[j] * (x_0[j][k] - x_0[i][k]) * rij5);
<span class="pp">#endif</span>
}</code></pre></div>
<p>i, j粒子間の加加速度計算。 <span class="math inline">$G m_j \left[ \frac { (\vec{v}_j - \vec{v}_i) } { ({r_{ij}^2 + \varepsilon^2 )}^{3/2} } - 3 \frac { \left[ (\vec{v}_j - \vec{v}_i) \cdot (\vec{x}_j - \vec{x}_i) \right] (\vec{x}_j - \vec{x}_i) } { ({r_{ij}^2 + \varepsilon^2 )}^{5/2} } \right]$</span></p>
<ol type="1">
<li>i i 粒子。</li>
<li>j j 粒子。</li>
<li>k ベクトル3成分。</li>
<li>m_j j 粒子の質量。</li>
<li>x_0[][4] 粒子の位置<span class="math inline"><em>x</em>, <em>y</em>, <em>z</em></span>の配列。</li>
<li>v_0[][4] 粒子の速度<span class="math inline"><em>v</em><sub><em>x</em></sub>, <em>v</em><sub><em>y</em></sub>, <em>v</em><sub><em>z</em></sub></span>の配列。</li>
<li>r_dot_v_ij[] i, j 粒子の相対位置ベクトルと相対速度ベクトルの内積の配列。</li>
<li>abs_r[] i, j 粒子間の距離。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:acc.c"><code class="sourceCode c"><span class="co">/*加速度indirect項*/</span>
<span class="dt">static</span> <span class="kw">inline</span> ALWAYS_INLINE <span class="dt">double</span> Acceleration_indirect(<span class="dt">int</span> i, <span class="dt">int</span> k, CONST <span class="dt">double</span> m_i, CONST <span class="dt">double</span> x_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> r_0[]){
  <span class="dt">double</span> r3;
  r3 = r_0[i]*r_0[i]*r_0[i];
  r3 = <span class="fl">1.0</span>/r3;

<span class="pp">#ifndef G</span>
  <span class="cf">return</span> - m_i * x_0[i][k] * r3;
<span class="pp">#else</span>
  <span class="cf">return</span> - G * m_i * x_0[i][k] * r3;
<span class="pp">#endif</span>
}</code></pre></div>
<p>加速度のindirect項計算。 <span class="math inline">$- G m_i \frac{\vec{x}_i}{r_i}$</span></p>
<ol type="1">
<li>i i 粒子。</li>
<li>k ベクトル3成分。</li>
<li>m_i i 粒子の質量。</li>
<li>x_0[][4] 粒子の位置<span class="math inline"><em>x</em>, <em>y</em>, <em>z</em></span>の配列。</li>
<li>r_0[] i 粒子の原点からの距離（原点は中心星を含めた重心）。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:acc.c"><code class="sourceCode c"><span class="co">/*加加速度indirect項*/</span>
<span class="dt">static</span> <span class="kw">inline</span> ALWAYS_INLINE <span class="dt">double</span> dAcceleration_indirect(<span class="dt">int</span> i, <span class="dt">int</span> k, CONST <span class="dt">double</span> m_i, CONST <span class="dt">double</span> x_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> v_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> r_0[], CONST <span class="dt">double</span> r_dot_v[]){
  <span class="dt">double</span> r3;
  <span class="dt">double</span> r5;
  r3 = r_0[i]*r_0[i]*r_0[i];
  r5 = r3*r_0[i]*r_0[i];
  r3 = <span class="fl">1.0</span>/r3;
  r5 = <span class="fl">1.0</span>/r5;

<span class="pp">#ifndef G</span>
  <span class="cf">return</span> - m_i * (v_0[i][k] * r3 - <span class="fl">3.0</span> * r_dot_v[i] * x_0[i][k] * r5);
<span class="pp">#else</span>
  <span class="cf">return</span> - G * m_i * (v_0[i][k] * r3 - <span class="fl">3.0</span> * r_dot_v[i] * x_0[i][k] * r5);
<span class="pp">#endif</span>
}</code></pre></div>
<p>加加速度のindirect項計算。 <span class="math inline">$- G m_i \left( \frac{\vec{v}_i}{r_i^3} - 3 \frac{(\vec{x}_i \cdot \vec{v}_i) \vec{x}_i}{r_i^5} \right)$</span></p>
<ol type="1">
<li>i i 粒子。</li>
<li>k ベクトル3成分。</li>
<li>m_i i 粒子の質量。</li>
<li>x_0[][4] 粒子の位置<span class="math inline"><em>x</em>, <em>y</em>, <em>z</em></span>の配列。</li>
<li>v_0[][4] 粒子の速度<span class="math inline"><em>v</em><sub><em>x</em></sub>, <em>v</em><sub><em>y</em></sub>, <em>v</em><sub><em>z</em></sub></span>の配列。</li>
<li>r_0[] i 粒子の原点からの距離（原点は中心星を含めた重心）。</li>
<li>r_dot_v_ij[] i, j 粒子の相対位置ベクトルと相対速度ベクトルの内積の配列。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:acc.c"><code class="sourceCode c"><span class="co">/*外力加速度*/</span>
<span class="dt">static</span> <span class="kw">inline</span> ALWAYS_INLINE <span class="dt">double</span> External_Acceleration(<span class="dt">int</span> i, <span class="dt">int</span> k, CONST <span class="dt">double</span> x_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> r_0[]){
  <span class="dt">double</span> r3;
  r3 = r_0[i]*r_0[i]*r_0[i];
  r3 = <span class="fl">1.0</span>/r3;

<span class="pp">#if !defined(G) &amp;&amp; !defined(M_0)</span>
  <span class="cf">return</span> - x_0[i][k] * r3;
<span class="pp">#else</span>
  <span class="cf">return</span> - G * M_0 * x_0[i][k] * r3;
<span class="pp">#endif</span>
}</code></pre></div>
<p>加速度の外力項。 <span class="math inline">$- G M_{\ast} \frac{\vec{x}_i}{r_i^3}$</span></p>
<ol type="1">
<li>i i 粒子。</li>
<li>k ベクトル3成分。</li>
<li>x_0[][4] 粒子の位置<span class="math inline"><em>x</em>, <em>y</em>, <em>z</em></span>の配列。</li>
<li>r_0[] i 粒子の原点からの距離（原点は中心星を含めた重心）。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:acc.c"><code class="sourceCode c"><span class="co">/*外力加加速度*/</span>
<span class="dt">static</span> <span class="kw">inline</span> ALWAYS_INLINE <span class="dt">double</span> External_dAcceleration(<span class="dt">int</span> i, <span class="dt">int</span> k, CONST <span class="dt">double</span> x_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> v_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> r_0[], CONST <span class="dt">double</span> r_dot_v[]){
  <span class="dt">double</span> r3;
  <span class="dt">double</span> r5;
  r3 = r_0[i]*r_0[i]*r_0[i];
  r5 = r3*r_0[i]*r_0[i];
  r3 = <span class="fl">1.0</span>/r3;
  r5 = <span class="fl">1.0</span>/r5;

<span class="pp">#if !defined(G) &amp;&amp; !defined(M_0)</span>
  <span class="cf">return</span> - (v_0[i][k] * r3 - <span class="fl">3.0</span> * r_dot_v[i] * x_0[i][k] * r5);
<span class="pp">#else</span>
  <span class="cf">return</span> - G M_0 * (v_0[i][k] * r3 - <span class="fl">3.0</span> * r_dot_v[i] * x_0[i][k] * r5);
<span class="pp">#endif</span>
}</code></pre></div>
<p>加加速度の外力項。 <span class="math inline">$- G M_{\ast} \left( \frac{\vec{v}_i}{r_i^3} - 3 \frac{(\vec{x}_i \cdot \vec{v}_i) \vec{x}_i}{r_i^5} \right)$</span></p>
<ol type="1">
<li>i i 粒子。</li>
<li>k ベクトル3成分。</li>
<li>x_0[][4] 粒子の位置<span class="math inline"><em>x</em>, <em>y</em>, <em>z</em></span>の配列。</li>
<li>v_0[][4] 粒子の速度<span class="math inline"><em>v</em><sub><em>x</em></sub>, <em>v</em><sub><em>y</em></sub>, <em>v</em><sub><em>z</em></sub></span>の配列。</li>
<li>r_0[] i 粒子の原点からの距離（原点は中心星を含めた重心）。</li>
<li>r_dot_v[] i 粒子の位置ベクトルと速度ベクトルの内積の配列。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:acc.c"><code class="sourceCode c"><span class="co">/*i_sys のみの修正子*/</span>
<span class="dt">void</span> Corrector_sys(<span class="dt">int</span> n_ite, <span class="dt">int</span> i_sys, CONST <span class="kw">struct</span> orbital_elements *ele_p, CONST <span class="dt">double</span> x_p[][<span class="dv">4</span>], CONST <span class="dt">double</span> v_p[][<span class="dv">4</span>], CONST <span class="dt">double</span> r_p[], <span class="dt">double</span> x_c[][<span class="dv">4</span>], <span class="dt">double</span> v_c[][<span class="dv">4</span>], <span class="dt">double</span> r_c[], <span class="dt">double</span> v2_c[], <span class="dt">double</span> r_dot_v[], CONST <span class="dt">double</span> a_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> adot_0[][<span class="dv">4</span>], <span class="dt">double</span> a[][<span class="dv">4</span>], <span class="dt">double</span> adot[][<span class="dv">4</span>], <span class="dt">double</span> adot2_dt2[][<span class="dv">4</span>], <span class="dt">double</span> adot3_dt3[][<span class="dv">4</span>], CONST <span class="dt">double</span> dt_[]
<span class="pp">#if FRAGMENTATION</span>
           , <span class="dt">double</span> t_dyn
           , CONST <span class="kw">struct</span> fragmentation *frag_p
<span class="pp">#endif</span>
           ){

  <span class="dt">int</span> j, k;
  <span class="dt">double</span> dt = dt_[i_sys];
  <span class="dt">double</span> abs_r[
<span class="pp">#if INTERACTION_ALL</span>
           global_n
<span class="pp">#elif INTERACTION_PLANET_TRACER</span>
           global_n
<span class="pp">#elif INTERACTION_TEST_PARTICLE</span>
           global_n_p
<span class="pp">#endif</span>
           +<span class="dv">1</span>];
  <span class="dt">double</span> r_dot_v_ij[
<span class="pp">#if INTERACTION_ALL</span>
            global_n
<span class="pp">#elif INTERACTION_PLANET_TRACER</span>
            global_n
<span class="pp">#elif INTERACTION_TEST_PARTICLE</span>
            global_n_p
<span class="pp">#endif</span>
            +<span class="dv">1</span>];
  <span class="dt">double</span> a_tmp[<span class="dv">4</span>]={}, adot_tmp[<span class="dv">4</span>]={}, adot2_dt2_tmp[<span class="dv">4</span>]={}, adot3_dt3_tmp[<span class="dv">4</span>]={};
  <span class="dt">double</span> x_c_tmp[<span class="dv">4</span>]={}, v_c_tmp[<span class="dv">4</span>]={};


  <span class="cf">for</span>(j=<span class="dv">1</span>;j&lt;=
<span class="pp">#if INTERACTION_ALL</span>
    global_n
<span class="pp">#elif INTERACTION_PLANET_TRACER</span>
    global_n
<span class="pp">#elif INTERACTION_TEST_PARTICLE</span>
    global_n_p
<span class="pp">#endif</span>
    ;++j){
    <span class="cf">if</span>(i_sys!=j){
      <span class="cf">if</span>(n_ite == <span class="dv">0</span>){
    abs_r[j] = RelativeDistance(i_sys,j,x_p);  <span class="co">//絶対値.</span>
    r_dot_v_ij[j] = RelativeInnerProduct(i_sys,j,x_p,v_p);  <span class="co">//r_ij,v_ijの内積.</span>
      }<span class="cf">else</span> <span class="cf">if</span>(n_ite &lt;= ITE_MAX){  <span class="co">//iterationではx_c,v_cを使う.</span>
    abs_r[j] = RelativeDistance(i_sys,j,x_c);  <span class="co">//絶対値.</span>
    r_dot_v_ij[j] = RelativeInnerProduct(i_sys,j,x_c,v_c);  <span class="co">//r_ij,v_ijの内積.</span>
      }
    }<span class="cf">else</span>{
      abs_r[i_sys] = <span class="fl">0.0</span>;
      r_dot_v_ij[i_sys] = <span class="fl">0.0</span>;
    }
  }


  <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){
    <span class="cf">if</span>(n_ite == <span class="dv">0</span>){
      a_tmp[k] = All_Acceleration(i_sys,k,ele_p,x_p,r_p,abs_r
<span class="pp">#if FRAGMENTATION</span>
                  ,t_dyn,frag_p
<span class="pp">#endif</span>
                  );
      adot_tmp[k] = All_dAcceleration(i_sys,k,ele_p,x_p,v_p,r_dot_v,r_dot_v_ij,r_p,abs_r
<span class="pp">#if FRAGMENTATION</span>
                  ,t_dyn,frag_p
<span class="pp">#endif</span>
                      );
    }<span class="cf">else</span> <span class="cf">if</span>(n_ite &lt;= ITE_MAX){  <span class="co">//iterationではx_c,v_cを使う.</span>
      a_tmp[k] = All_Acceleration(i_sys,k,ele_p,x_c,r_c,abs_r
<span class="pp">#if FRAGMENTATION</span>
                  ,t_dyn,frag_p
<span class="pp">#endif</span>
                  );
      adot_tmp[k] = All_dAcceleration(i_sys,k,ele_p,x_c,v_c,r_dot_v,r_dot_v_ij,r_c,abs_r
<span class="pp">#if FRAGMENTATION</span>
                  ,t_dyn,frag_p
<span class="pp">#endif</span>
                      );
    }
  }


  <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){  <span class="co">//修正子.</span>

    adot2_dt2_tmp[k] = - <span class="fl">6.0</span> * (a_0[i_sys][k] - a_tmp[k]) - (<span class="fl">4.0</span> * adot_0[i_sys][k] + <span class="fl">2.0</span> * adot_tmp[k]) * dt; <span class="co">//第2次導関数.</span>
    adot3_dt3_tmp[k] = <span class="fl">12.0</span> * (a_0[i_sys][k] - a_tmp[k]) + <span class="fl">6.0</span> * (adot_0[i_sys][k] + adot_tmp[k]) * dt; <span class="co">//第3次導関数.</span>

    <span class="co">//x_c_tmp[k] = x_p[i_sys][k] + adot2_dt2_tmp[k]*dt_[i_sys]*dt_[i_sys]/24.0 + adot3_dt3_tmp[k]*dt_[i_sys]*dt_[i_sys]/120.0;</span>
    <span class="co">//v_c_tmp[k] = v_p[i_sys][k] + adot2_dt2_tmp[k]*dt_[i_sys]/6.0 +adot3_dt3_tmp[k]*dt_[i_sys]/24.0;</span>

    x_c_tmp[k] = x_p[i_sys][k] + dt * dt * <span class="fl">0.125</span> * INV_3 * (adot2_dt2_tmp[k] + adot3_dt3_tmp[k] * <span class="fl">0.2</span>);
    v_c_tmp[k] = v_p[i_sys][k] + dt * <span class="fl">0.5</span> * INV_3 * (adot2_dt2_tmp[k] + adot3_dt3_tmp[k] * <span class="fl">0.25</span>);
  }  <span class="co">//k loop</span>


  r_c[i_sys] = sqrt(x_c_tmp[<span class="dv">1</span>]*x_c_tmp[<span class="dv">1</span>] + x_c_tmp[<span class="dv">2</span>]*x_c_tmp[<span class="dv">2</span>] + x_c_tmp[<span class="dv">3</span>]*x_c_tmp[<span class="dv">3</span>]);
  v2_c[i_sys] = v_c_tmp[<span class="dv">1</span>]*v_c_tmp[<span class="dv">1</span>] + v_c_tmp[<span class="dv">2</span>]*v_c_tmp[<span class="dv">2</span>] + v_c_tmp[<span class="dv">3</span>]*v_c_tmp[<span class="dv">3</span>];
  r_dot_v[i_sys] = x_c_tmp[<span class="dv">1</span>]*v_c_tmp[<span class="dv">1</span>] + x_c_tmp[<span class="dv">2</span>]*v_c_tmp[<span class="dv">2</span>] + x_c_tmp[<span class="dv">3</span>]*v_c_tmp[<span class="dv">3</span>];


  <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){
    a[i_sys][k] = a_tmp[k];
    adot[i_sys][k] = adot_tmp[k];
    adot2_dt2[i_sys][k] = adot2_dt2_tmp[k];
    adot3_dt3[i_sys][k] = adot3_dt3_tmp[k];
    x_c[i_sys][k] = x_c_tmp[k];
    v_c[i_sys][k] = v_c_tmp[k];
  }

  <span class="cf">return</span>;
}</code></pre></div>
<p>修正子計算。</p>
<p>a_tmp[]などを新たにローカル関数として定義している理由は、加速度の関数All_Accelerationと加加速度の関数All_dAcceleration内で並列化をする際に、別の粒子を抜け駆けで更新しないようにするため。</p>
<ol type="1">
<li>n_ite イテレーション回数。</li>
<li>i_sys システム粒子。</li>
<li>*ele_p 軌道要素の構造体のポインタ。</li>
<li>x_p[][4] 位置の予測子。</li>
<li>v_p[][4] 速度の予測子。</li>
<li>r_p[] 中心星からの距離の予測子。</li>
<li>x_c[][4] 位置の修正子。</li>
<li>v_c[][4] 速度の修正子。</li>
<li>r_c[] 中心星からの距離の修正子。</li>
<li>v2_c[] 速度の修正子の大きさの2乗。</li>
<li>r_dot_v[] 位置ベクトルと速度ベクトルの内積。</li>
<li>a_0[][4] 現時点の加速度。</li>
<li>adot_0[][4] 現時点の加加速度。</li>
<li>a[][4] 次のステップの加速度。</li>
<li>adot[][4] 次のステップの加加速度。</li>
<li>adot2_dt2[][4] 次のステップの加速度の第2次導関数 × タイムステップの2乗。</li>
<li>adot3_dt3[][4] 次のステップの加速度の第3次導関数 × タイムステップの3乗。</li>
<li>dt_[] 粒子毎のタイムステップ。</li>
<li>t_dyn システム時間。破壊計算で質量は減少するのでその見積もり用。</li>
<li>*frag_p 破壊計算に必要なデータをもつ構造体ポインタ。破壊計算で質量は減少するのでその見積もり用。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:acc.c"><code class="sourceCode c"><span class="co">/*全加速度*/</span>
<span class="dt">double</span> All_Acceleration(<span class="dt">int</span> i, <span class="dt">int</span> k, CONST <span class="kw">struct</span> orbital_elements *ele_p, CONST <span class="dt">double</span> x_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> r_0[], CONST <span class="dt">double</span> abs_r[]
<span class="pp">#if FRAGMENTATION</span>
            , <span class="dt">double</span> t_dyn
            , CONST <span class="kw">struct</span> fragmentation *frag_p
<span class="pp">#endif</span>
            ){
  <span class="dt">int</span> j;
  <span class="dt">double</span> a_0;
  <span class="dt">double</span> m_j;

  a_0 = External_Acceleration(i,k,x_0,r_0);

<span class="pp">#if INTERACTION_PLANET_TRACER</span>
  <span class="cf">if</span>(i&gt;global_n_p){  <span class="co">//i_sysがトレーサーの場合，惑星からの影響を計算.</span>
<span class="pp">#endif</span>

<span class="pp">#if INTERACTION_ALL</span>
<span class="pp">#pragma omp parallel for reduction(+:a_0)</span>
<span class="pp">#endif</span>
    <span class="cf">for</span>(j=<span class="dv">1</span>;j&lt;=
<span class="pp">#if INTERACTION_ALL</span>
      global_n
<span class="pp">#elif INTERACTION_PLANET_TRACER</span>
      global_n_p
<span class="pp">#elif INTERACTION_TEST_PARTICLE</span>
      global_n_p
<span class="pp">#endif</span>
      ;++j){

<span class="pp">#if FRAGMENTATION</span>
      m_j = MassDepletion(j,((ele_p+j)-&gt;mass),t_dyn,frag_p);
<span class="pp">#else</span>
      m_j = ((ele_p+j)-&gt;mass);
<span class="pp">#endif</span>

<span class="pp">#if INDIRECT_TERM</span>
      a_0 += Acceleration_indirect(j,k,m_j,x_0,r_0);
<span class="pp">#endif</span>

      <span class="cf">if</span>(i!=j){
        a_0 += Acceleration_ij(i,j,k,m_j,x_0,abs_r);
      }
    }



<span class="pp">#if INTERACTION_PLANET_TRACER</span>
  }<span class="cf">else</span> <span class="cf">if</span>(i&lt;=global_n_p){  <span class="co">//i_sysが惑星の場合，自身以外のすべてからの影響を計算.</span>

<span class="pp">#pragma omp parallel for reduction(+:a_0)</span>
    <span class="cf">for</span>(j=<span class="dv">1</span>;j&lt;=global_n;++j){

<span class="pp">#if FRAGMENTATION</span>
      m_j = MassDepletion(j,((ele_p+j)-&gt;mass),t_dyn,frag_p);
<span class="pp">#else</span>
      m_j = ((ele_p+j)-&gt;mass);
<span class="pp">#endif</span>

<span class="pp">#if INDIRECT_TERM</span>
      a_0 += Acceleration_indirect(j,k,m_j,x_0,r_0);
<span class="pp">#endif</span>

      <span class="cf">if</span>(i!=j){
        a_0 += Acceleration_ij(i,j,k,m_j,x_0,abs_r);
      }
    }

  }
<span class="pp">#endif</span>

  <span class="cf">return</span> a_0;
}</code></pre></div>
<p>i 粒子の加速度。</p>
<ol type="1">
<li>i i 粒子。</li>
<li>k ベクトル3成分。</li>
<li>*ele_p 軌道要素の構造体のポインタ。</li>
<li>x_0[][4] 粒子の位置<span class="math inline"><em>x</em>, <em>y</em>, <em>z</em></span>の配列。</li>
<li>r_0[] i 粒子の原点からの距離（原点は中心星を含めた重心）。</li>
<li>abs_r[] i, j 粒子間の距離。</li>
<li>t_dyn システム時間。破壊計算で質量は減少するのでその見積もり用。</li>
<li>*frag_p 破壊計算に必要なデータをもつ構造体ポインタ。破壊計算で質量は減少するのでその見積もり用。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:acc.c"><code class="sourceCode c"><span class="co">/*全加加速度*/</span>
<span class="dt">double</span> All_dAcceleration(<span class="dt">int</span> i, <span class="dt">int</span> k, CONST <span class="kw">struct</span> orbital_elements *ele_p, CONST <span class="dt">double</span> x_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> v_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> r_dot_v[], CONST <span class="dt">double</span> r_dot_v_ij[], CONST <span class="dt">double</span> r_0[], CONST <span class="dt">double</span> abs_r[]
<span class="pp">#if FRAGMENTATION</span>
             , <span class="dt">double</span> t_dyn
             , CONST <span class="kw">struct</span> fragmentation *frag_p
<span class="pp">#endif</span>
             ){
  <span class="dt">int</span> j;
  <span class="dt">double</span> adot_0;
  <span class="dt">double</span> m_j;

  adot_0 = External_dAcceleration(i,k,x_0,v_0,r_0,r_dot_v);

<span class="pp">#if INTERACTION_PLANET_TRACER</span>
  <span class="cf">if</span>(i&gt;global_n_p){  <span class="co">//i_sysがトレーサーの場合，惑星からの影響を計算.</span>
<span class="pp">#endif</span>

<span class="pp">#if INTERACTION_ALL</span>
<span class="pp">#pragma omp parallel for reduction(+:adot_0)</span>
<span class="pp">#endif</span>
    <span class="cf">for</span>(j=<span class="dv">1</span>;j&lt;=
<span class="pp">#if INTERACTION_ALL</span>
      global_n
<span class="pp">#elif INTERACTION_PLANET_TRACER</span>
      global_n_p
<span class="pp">#elif INTERACTION_TEST_PARTICLE</span>
      global_n_p
<span class="pp">#endif</span>
      ;++j){

<span class="pp">#if FRAGMENTATION</span>
      m_j = MassDepletion(j,((ele_p+j)-&gt;mass),t_dyn,frag_p);
<span class="pp">#else</span>
      m_j = ((ele_p+j)-&gt;mass);
<span class="pp">#endif</span>

<span class="pp">#if INDIRECT_TERM</span>
      adot_0 += dAcceleration_indirect(j,k,m_j,x_0,v_0,r_0,r_dot_v);
<span class="pp">#endif</span>

      <span class="cf">if</span>(i!=j){
        adot_0 += dAcceleration_ij(i,j,k,m_j,x_0,v_0,r_dot_v_ij,abs_r);
      }
    }

<span class="pp">#if INTERACTION_PLANET_TRACER</span>
  }<span class="cf">else</span> <span class="cf">if</span>(i&lt;=global_n_p){  <span class="co">//i_sysが惑星の場合，自身以外のすべてからの影響を計算.</span>

<span class="pp">#pragma omp parallel for reduction(+:adot_0)</span>
    <span class="cf">for</span>(j=<span class="dv">1</span>;j&lt;=global_n;++j){

<span class="pp">#if FRAGMENTATION</span>
      m_j = MassDepletion(j,((ele_p+j)-&gt;mass),t_dyn,frag_p);
<span class="pp">#else</span>
      m_j = ((ele_p+j)-&gt;mass);
<span class="pp">#endif</span>

<span class="pp">#if INDIRECT_TERM</span>
      adot_0 += dAcceleration_indirect(j,k,m_j,x_0,v_0,r_0,r_dot_v);
<span class="pp">#endif</span>

      <span class="cf">if</span>(i!=j){
        adot_0 += dAcceleration_ij(i,j,k,m_j,x_0,v_0,r_dot_v_ij,abs_r);
      }
    }

  }
<span class="pp">#endif</span>

  <span class="cf">return</span> adot_0;
}</code></pre></div>
<p>i 粒子の加加速度。</p>
<ol type="1">
<li>i i 粒子。</li>
<li>k ベクトル3成分。</li>
<li>*ele_p 軌道要素の構造体のポインタ。</li>
<li>x_0[][4] 粒子の位置<span class="math inline"><em>x</em>, <em>y</em>, <em>z</em></span>の配列。</li>
<li>v_0[][4] 粒子の速度<span class="math inline"><em>v</em><sub><em>x</em></sub>, <em>v</em><sub><em>y</em></sub>, <em>v</em><sub><em>z</em></sub></span>の配列。</li>
<li>r_dot_v[] i 粒子の位置ベクトルと速度ベクトルの内積の配列。</li>
<li>r_dot_v_ij[] i, j 粒子の相対位置ベクトルと相対速度ベクトルの内積の配列。</li>
<li>r_0[] i 粒子の原点からの距離（原点は中心星を含めた重心）。</li>
<li>abs_r[] i, j 粒子間の距離。</li>
<li>t_dyn システム時間。破壊計算で質量は減少するのでその見積もり用。</li>
<li>*frag_p 破壊計算に必要なデータをもつ構造体ポインタ。破壊計算で質量は減少するのでその見積もり用。</li>
</ol>
<h2 id="collision.c-1">collision.c</h2>
<div class="sourceCode"><pre class="sourceCode c:collision.c"><code class="sourceCode c">bool Collision_Judgement(<span class="dt">int</span> i_sys, CONST <span class="kw">struct</span> orbital_elements *ele_p, CONST <span class="dt">double</span> x_p[][<span class="dv">4</span>], <span class="dt">double</span> abs_r[], <span class="dt">int</span> *i_col, <span class="dt">int</span> *j_col){


<span class="pp">#if EXECUTION_TIME &amp;&amp; EXECUTION_TIME_FUNC</span>
  <span class="kw">struct</span> timeval realtime_start, realtime_end;
  <span class="kw">struct</span> rusage usage_start, usage_end;
  gettimeofday(&amp;realtime_start,NULL);
  getrusage(RUSAGE_SELF,&amp;usage_start);
<span class="pp">#endif</span>


  <span class="dt">int</span> j;

  <span class="cf">for</span>(j=<span class="dv">1</span>;j&lt;=global_n;++j){
    <span class="cf">if</span>(i_sys!=j){
      abs_r[j] = RelativeDistance(i_sys,j,x_p);  <span class="co">//絶対値.</span>
      <span class="cf">if</span>(abs_r[j] &lt; ((ele_p+i_sys)-&gt;radius) + ((ele_p+j)-&gt;radius)){
        (*i_col) = Min_int(i_sys,j);
        (*j_col) = Max_int(i_sys,j);

<span class="pp">#if EXECUTION_TIME &amp;&amp; EXECUTION_TIME_FUNC</span>
        gettimeofday(&amp;realtime_end,NULL);
        getrusage(RUSAGE_SELF,&amp;usage_end);
        exetime.Collision_Judgement[<span class="dv">0</span>] += Cal_time(realtime_start,realtime_end);
        exetime.Collision_Judgement[<span class="dv">1</span>] += Cal_time(usage_start.ru_utime,usage_end.ru_utime);
        exetime.Collision_Judgement[<span class="dv">2</span>] += Cal_time(usage_start.ru_stime,usage_end.ru_stime);
<span class="pp">#endif</span>

        <span class="cf">return</span> (true);  <span class="co">//衝突した場合.</span>
      }
    }
  }


<span class="pp">#if EXECUTION_TIME &amp;&amp; EXECUTION_TIME_FUNC</span>
  gettimeofday(&amp;realtime_end,NULL);
  getrusage(RUSAGE_SELF,&amp;usage_end);
  exetime.Collision_Judgement[<span class="dv">0</span>] += Cal_time(realtime_start,realtime_end);
  exetime.Collision_Judgement[<span class="dv">1</span>] += Cal_time(usage_start.ru_utime,usage_end.ru_utime);
  exetime.Collision_Judgement[<span class="dv">2</span>] += Cal_time(usage_start.ru_stime,usage_end.ru_stime);
<span class="pp">#endif</span>

  <span class="cf">return</span> (false);  <span class="co">//衝突しない場合.</span>
}</code></pre></div>
<p>衝突判定。</p>
<ol type="1">
<li>i_sys システム粒子。</li>
<li>*ele_p 軌道要素の構造体ポインタ。</li>
<li>x_p[][4] 位置の予測子。</li>
<li>abs_r[] i, j 粒子間の距離。</li>
<li>*i_col 衝突した粒子番号ポインタ。若い方。</li>
<li>*j_col 衝突した粒子番号ポインタ。もう一つ。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:collision.c"><code class="sourceCode c"><span class="dt">void</span> Energy_Correction(<span class="dt">int</span> i_col, <span class="dt">int</span> j_col, CONST <span class="dt">double</span> x_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> v_0[][<span class="dv">4</span>], CONST <span class="kw">struct</span> orbital_elements *ele_p, <span class="dt">double</span> *dE_heat, <span class="dt">double</span> *dE_grav, <span class="dt">double</span> *dE_c, <span class="dt">double</span> *v_imp
<span class="pp">#if FRAGMENTATION</span>
               , <span class="dt">double</span> t_dyn
               , CONST <span class="kw">struct</span> fragmentation *frag_p
<span class="pp">#endif</span>
               ){

  <span class="dt">double</span> m_1, m_2;
  <span class="dt">double</span> abs_v2 = SquareOfRelativeVelocity(i_col,j_col,v_0);  <span class="co">//相対速度2乗.</span>
  <span class="dt">double</span> r_p12 = RelativeDistance(i_col,j_col,x_0);  <span class="co">//2粒子間の距離.</span>
  <span class="dt">double</span> r_g12 = RadiusFromCenter(<span class="dv">0</span>,x_0);  <span class="co">//2粒子の重心と中心星との距離.</span>
  <span class="dt">double</span> r_1 = RadiusFromCenter(i_col,x_0);
  <span class="dt">double</span> r_2 = RadiusFromCenter(j_col,x_0);

<span class="pp">#if FRAGMENTATION</span>
  m_1 = MassDepletion(i_col,((ele_p+i_col)-&gt;mass),t_dyn,frag_p);
  m_2 = MassDepletion(j_col,((ele_p+j_col)-&gt;mass),t_dyn,frag_p);
<span class="pp">#else</span>
  m_1 = ((ele_p+i_col)-&gt;mass);
  m_2 = ((ele_p+j_col)-&gt;mass);
<span class="pp">#endif</span>

  (*dE_heat) = - <span class="fl">0.5</span> * m_1 * m_2 / (m_1 + m_2) * abs_v2;  <span class="co">//完全合体することで、相対速度分の運動エネルギーが熱エネルギーとなって散逸する.</span>

<span class="pp">#ifndef G</span>
  (*dE_grav) = m_1 * m_2 / r_p12;  <span class="co">//2粒子間の距離に対応する相互重力エネルギーがなくなっている.</span>
<span class="pp">#else</span>
  (*dE_grav) = G * m_1 * m_2 / r_p12;  <span class="co">//2粒子間の距離に対応する相互重力エネルギーがなくなっている.</span>
<span class="pp">#endif</span>

<span class="pp">#if !defined(G) &amp;&amp; !defined(M_0)</span>
  (*dE_c) = - (m_1 + m_2) / r_g12 + m_1 / r_1 + m_2 / r_2;  <span class="co">//中心星ポテンシャルエネルギーが変わる.</span>
<span class="pp">#else</span>
  (*dE_c) = G * M_0 * (- (m_1 + m_2) / r_g12 + m_1 / r_1 + m_2 / r_2);  <span class="co">//中心星ポテンシャルエネルギーが変わる.</span>
<span class="pp">#endif</span>

  (*v_imp) = sqrt(abs_v2);

  fprintf(fplog,<span class="st">&quot;dE_heat=%e</span><span class="sc">\t</span><span class="st">dE_grav=%e</span><span class="sc">\t</span><span class="st">dE_c=%e</span><span class="sc">\t</span><span class="st">v_imp=%e</span><span class="sc">\n</span><span class="st">&quot;</span>,(*dE_heat),(*dE_grav),(*dE_c),(*v_imp));

  <span class="cf">return</span>;
}</code></pre></div>
<p>衝突時のエネルギー補正。</p>
<ol type="1">
<li>i_col 衝突した粒子。若い方。</li>
<li>j_col 衝突した粒子。もう一つ。</li>
<li>x_0[][4] 位置。</li>
<li>v_0[][4] 速度。</li>
<li>*ele_p 軌道要素の構造体ポインタ。</li>
<li>*dE_heat 合体時に相対速度分の運動エネルギーが熱として散逸する量を表すポインタ。</li>
<li>*dE_grav 衝突した2粒子間の相互重力エネルギーが消える量を表すポインタ。</li>
<li>*dE_c 中心星ポテンシャルエネルギーが変わる量を表すポインタ。</li>
<li>*v_imp 衝突速度を表すポインタ。</li>
<li>t_dyn システム時間。破壊計算で質量は減少するのでその見積もり用。</li>
<li>*frag_p 破壊計算に必要なデータをもつ構造体ポインタ。破壊計算で質量は減少するのでその見積もり用。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:collision.c"><code class="sourceCode c"><span class="dt">void</span> Coalescence(<span class="dt">int</span> i_col, <span class="dt">int</span> j_col, <span class="dt">double</span> x_0[][<span class="dv">4</span>], <span class="dt">double</span> v_0[][<span class="dv">4</span>], <span class="kw">struct</span> orbital_elements *ele_p
<span class="pp">#if FRAGMENTATION</span>
         , <span class="dt">double</span> t_dyn
         , <span class="kw">struct</span> fragmentation *frag_p
<span class="pp">#endif</span>
         ){

  <span class="dt">int</span> k;

  <span class="co">//i_colを新しい合体粒子の番号にする.</span>
<span class="pp">#if FRAGMENTATION</span>
  ((ele_p+i_col)-&gt;mass) = MassDepletion(i_col,((ele_p+i_col)-&gt;mass),t_dyn,frag_p) + MassDepletion(j_col,((ele_p+j_col)-&gt;mass),t_dyn,frag_p);
<span class="pp">#else</span>
  ((ele_p+i_col)-&gt;mass) = ((ele_p+i_col)-&gt;mass) + ((ele_p+j_col)-&gt;mass);
<span class="pp">#endif</span>
  ((ele_p+i_col)-&gt;radius) = cbrt(<span class="fl">3.0</span>/<span class="fl">4.0</span>/M_PI*((ele_p+i_col)-&gt;mass)*<span class="fl">1.989E33</span>/PLANET_DENSITY)/<span class="fl">1.496E13</span>;
  <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){
    x_0[i_col][k] = x_0[<span class="dv">0</span>][k];
    v_0[i_col][k] = v_0[<span class="dv">0</span>][k];
  }

  <span class="cf">if</span>(j_col&lt;=global_n_p){

    <span class="co">//惑星同士の衝突合体</span>
    <span class="co">//j_colとglobal_n_pを入れ替える.</span>
    *(ele_p+<span class="dv">0</span>) = *(ele_p+j_col);  <span class="co">//構造体のためSwap関数は使えない. 0番目の要素はコピーに使うだけ.</span>
    *(ele_p+j_col) = *(ele_p+global_n_p);
    *(ele_p+global_n_p) = *(ele_p+<span class="dv">0</span>);
<span class="pp">#if FRAGMENTATION</span>
    *(frag_p+<span class="dv">0</span>) = *(frag_p+j_col);  <span class="co">//構造体のためSwap関数は使えない. 0番目の要素はコピーに使うだけ.</span>
    *(frag_p+j_col) = *(frag_p+global_n_p);
    *(frag_p+global_n_p) = *(frag_p+<span class="dv">0</span>);
<span class="pp">#endif</span>
    <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){
      Swap_double(&amp;x_0[j_col][k],&amp;x_0[global_n_p][k]);
      Swap_double(&amp;v_0[j_col][k],&amp;v_0[global_n_p][k]);
    }

<span class="pp">#if N_tr != 0</span>
    <span class="co">//global_n_pとglobal_nを入れ替える.</span>
    *(ele_p+<span class="dv">0</span>) = *(ele_p+global_n_p);  <span class="co">//構造体のためSWAP関数は使えない. 0番目の要素はコピーに使うだけ.</span>
    *(ele_p+global_n_p) = *(ele_p+global_n);
    *(ele_p+global_n) = *(ele_p+<span class="dv">0</span>);
<span class="pp">#if FRAGMENTATION</span>
    *(frag_p+<span class="dv">0</span>) = *(frag_p+global_n_p);  <span class="co">//構造体のためSWAP関数は使えない. 0番目の要素はコピーに使うだけ.</span>
    *(frag_p+global_n_p) = *(frag_p+global_n);
    *(frag_p+global_n) = *(frag_p+<span class="dv">0</span>);
<span class="pp">#endif</span>
    <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){
      Swap_double(&amp;x_0[global_n_p][k],&amp;x_0[global_n][k]);
      Swap_double(&amp;v_0[global_n_p][k],&amp;v_0[global_n][k]);
    }
<span class="pp">#endif</span>

    <span class="co">//global_n_p,global_nを1つ減らす.</span>
    global_n_p--;
    global_n--;

  }<span class="cf">else</span> <span class="cf">if</span>(j_col&gt;global_n_p){

    <span class="co">//惑星-微惑星の衝突合体</span>
    <span class="co">//j_colとglobal_nを入れ替える.</span>
    *(ele_p+<span class="dv">0</span>) = *(ele_p+j_col);  <span class="co">//構造体のためSwap関数は使えない. 0番目の要素はコピーに使うだけ.</span>
    *(ele_p+j_col) = *(ele_p+global_n);
    *(ele_p+global_n) = *(ele_p+<span class="dv">0</span>);
<span class="pp">#if FRAGMENTATION</span>
    *(frag_p+<span class="dv">0</span>) = *(frag_p+j_col);  <span class="co">//構造体のためSwap関数は使えない. 0番目の要素はコピーに使うだけ.</span>
    *(frag_p+j_col) = *(frag_p+global_n);
    *(frag_p+global_n) = *(frag_p+<span class="dv">0</span>);
<span class="pp">#endif</span>
    <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){
      Swap_double(&amp;x_0[j_col][k],&amp;x_0[global_n][k]);
      Swap_double(&amp;v_0[j_col][k],&amp;v_0[global_n][k]);
    }

    <span class="co">//global_nを1つ減らす.</span>
    global_n--;
  }

  <span class="cf">return</span>;
}</code></pre></div>
<p>衝突・合体計算。</p>
<ol type="1">
<li>i_col 衝突した粒子。若い方。</li>
<li>j_col 衝突した粒子。もう一つ。</li>
<li>x_0[][4] 位置。</li>
<li>v_0[][4] 速度。</li>
<li>*ele_p 軌道要素の構造体ポインタ。</li>
<li>t_dyn システム時間。破壊計算で質量は減少するのでその見積もり用。</li>
<li>*frag_p 破壊計算に必要なデータをもつ構造体ポインタ。破壊計算で質量は減少するのでその見積もり用。</li>
</ol>
<h2 id="energy.c-1">energy.c</h2>
<p>エネルギー計算</p>
<div class="sourceCode"><pre class="sourceCode c:energy.c"><code class="sourceCode c"><span class="dt">double</span> Calculate_Energy(CONST <span class="kw">struct</span> orbital_elements *ele_p, CONST <span class="dt">double</span> x_c[][<span class="dv">4</span>]
<span class="pp">#if INDIRECT_TERM</span>
            , CONST <span class="dt">double</span> v_c[][<span class="dv">4</span>], CONST <span class="dt">double</span> v_G[]
<span class="pp">#else</span>
            , CONST <span class="dt">double</span> v2_c[]
<span class="pp">#endif</span>
            , CONST <span class="dt">double</span> r_c[]
<span class="pp">#if FRAGMENTATION</span>
            , <span class="dt">double</span> t_dyn
            , CONST <span class="kw">struct</span> fragmentation *frag_p
<span class="pp">#endif</span>
            ){

  <span class="dt">int</span> i,j;
  <span class="dt">double</span> abs_rij;
  <span class="dt">double</span> E[global_n+<span class="dv">1</span>];
  <span class="dt">double</span> E_tot;
  <span class="dt">double</span> m_i,m_j;

<span class="pp">#if INDIRECT_TERM</span>
<span class="pp">#ifndef M_0</span>
  E_tot = <span class="fl">0.5</span> * (v_G[<span class="dv">1</span>]*v_G[<span class="dv">1</span>] + v_G[<span class="dv">2</span>]*v_G[<span class="dv">2</span>] + v_G[<span class="dv">3</span>]*v_G[<span class="dv">3</span>]);
<span class="pp">#else</span>
  E_tot = <span class="fl">0.5</span> * M_0 * (v_G[<span class="dv">1</span>]*v_G[<span class="dv">1</span>] + v_G[<span class="dv">2</span>]*v_G[<span class="dv">2</span>] + v_G[<span class="dv">3</span>]*v_G[<span class="dv">3</span>]);
<span class="pp">#endif</span>

<span class="pp">#else</span>
  E_tot = <span class="fl">0.0</span>;
<span class="pp">#endif</span>

  <span class="cf">for</span>(i=<span class="dv">1</span>;i&lt;=global_n;++i){

<span class="pp">#if FRAGMENTATION</span>
    m_i = MassDepletion(i,((ele_p+i)-&gt;mass),t_dyn,frag_p);
<span class="pp">#else</span>
    m_i = ((ele_p+i)-&gt;mass);
<span class="pp">#endif</span>

<span class="pp">#if INDIRECT_TERM</span>
    E[i] = <span class="fl">0.5</span> * m_i * ((v_c[i][<span class="dv">1</span>]-v_G[<span class="dv">1</span>])*(v_c[i][<span class="dv">1</span>]-v_G[<span class="dv">1</span>]) + (v_c[i][<span class="dv">2</span>]-v_G[<span class="dv">2</span>])*(v_c[i][<span class="dv">2</span>]-v_G[<span class="dv">2</span>]) + (v_c[i][<span class="dv">3</span>]-v_G[<span class="dv">3</span>])*(v_c[i][<span class="dv">3</span>]-v_G[<span class="dv">3</span>]));
<span class="pp">#else</span>
    E[i] = <span class="fl">0.5</span> * m_i * v2_c[i];
<span class="pp">#endif</span>

<span class="pp">#if !INTERACTION_TEST_PARTICLE</span>

<span class="pp">#if INTERACTION_PLANET_TRACER</span>
    <span class="cf">if</span>(i&lt;=global_n_p){
<span class="pp">#endif</span>

      <span class="cf">for</span>(j=i+<span class="dv">1</span>;j&lt;=global_n;++j){

<span class="pp">#if FRAGMENTATION</span>
    m_j = MassDepletion(j,((ele_p+j)-&gt;mass),t_dyn,frag_p);
<span class="pp">#else</span>
    m_j = ((ele_p+j)-&gt;mass);
<span class="pp">#endif</span>

    abs_rij = RelativeDistance(i,j,x_c); <span class="co">//絶対値.</span>

<span class="pp">#ifndef G</span>
    E[i] += - m_i * m_j / abs_rij;  <span class="co">//エネルギー計算.</span>
<span class="pp">#else</span>
    E[i] += - G * m_i * m_j / abs_rij;  <span class="co">//エネルギー計算.</span>
<span class="pp">#endif</span>

      }  <span class="co">//j loop</span>

<span class="pp">#if INTERACTION_PLANET_TRACER</span>
    }
<span class="pp">#endif</span>

<span class="pp">#endif  </span><span class="co">/*!INTERACTION_TEST_PARTICLE*/</span>

<span class="pp">#if !defined(G) &amp;&amp; !defined(M_0)</span>
    E_tot += - m_i / r_c[i] + E[i];
<span class="pp">#else</span>
    E_tot += - G * M_0 * m_i / r_c[i] + E[i];
<span class="pp">#endif</span>

  }  <span class="co">//i loop</span>
  <span class="cf">return</span> E_tot;
}</code></pre></div>
<p>全エネルギー計算。</p>
<ol type="1">
<li>*ele_p 軌道要素の構造体ポインタ。</li>
<li>x_c[][4] 位置の修正子。</li>
<li>v_c[][4] 速度の修正子。</li>
<li>v_G[] 重心速度。</li>
<li>v2_c[] 速度の修正子の大きさの2乗。</li>
<li>r_c[] 中心星からの距離。</li>
<li>t_dyn システム時間。破壊計算で質量は減少するのでその見積もり用。</li>
<li>*frag_p 破壊計算に必要なデータをもつ構造体ポインタ。破壊計算で質量は減少するのでその見積もり用。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:energy.c"><code class="sourceCode c"><span class="dt">double</span> AngularMomentum(CONST <span class="kw">struct</span> orbital_elements *ele_p, CONST <span class="dt">double</span> x_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> v_0[][<span class="dv">4</span>]
<span class="pp">#if FRAGMENTATION</span>
               , <span class="dt">double</span> t_dyn
               , CONST <span class="kw">struct</span> fragmentation *frag_p
<span class="pp">#endif</span>
               ){
  <span class="dt">int</span> i, k;
  <span class="dt">double</span> L[global_n+<span class="dv">1</span>][<span class="dv">4</span>];
  <span class="dt">double</span> L_tot_0[<span class="dv">4</span>];
  <span class="dt">double</span> m_i;


  <span class="cf">for</span>(i=<span class="dv">1</span>;i&lt;=global_n;++i){

<span class="pp">#if FRAGMENTATION</span>
    m_i = MassDepletion(i,((ele_p+i)-&gt;mass),t_dyn,frag_p);
<span class="pp">#else</span>
    m_i = ((ele_p+i)-&gt;mass);
<span class="pp">#endif</span>

    L[i][<span class="dv">1</span>] = m_i * (x_0[i][<span class="dv">2</span>]*v_0[i][<span class="dv">3</span>] - x_0[i][<span class="dv">3</span>]*v_0[i][<span class="dv">2</span>]);
    L[i][<span class="dv">2</span>] = m_i * (x_0[i][<span class="dv">3</span>]*v_0[i][<span class="dv">1</span>] - x_0[i][<span class="dv">1</span>]*v_0[i][<span class="dv">3</span>]);
    L[i][<span class="dv">3</span>] = m_i * (x_0[i][<span class="dv">1</span>]*v_0[i][<span class="dv">2</span>] - x_0[i][<span class="dv">2</span>]*v_0[i][<span class="dv">1</span>]);
    <span class="co">//fprintf(fplog,&quot;i=%d\t(ele_p+i)-&gt;mass=%e\n&quot;,i,(ele_p+i)-&gt;mass);</span>
    <span class="co">//fprintf(fplog,&quot;L[%d][1] = %e\t[2] = %e\t[3] = %e\n&quot;,i,L[i][1],L[i][2],L[i][3]);</span>
  }

  <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){
    L_tot_0[k] = <span class="fl">0.0</span>;
    <span class="cf">for</span>(i=<span class="dv">1</span>;i&lt;=global_n;++i){
      L_tot_0[k] += L[i][k];
    }
  }

  <span class="cf">return</span> sqrt(L_tot_0[<span class="dv">1</span>]*L_tot_0[<span class="dv">1</span>] + L_tot_0[<span class="dv">2</span>]*L_tot_0[<span class="dv">2</span>] + L_tot_0[<span class="dv">3</span>]*L_tot_0[<span class="dv">3</span>]);
}</code></pre></div>
<p>全角運動量計算。</p>
<ol type="1">
<li>*ele_p 軌道要素の構造体ポインタ。</li>
<li>x_0[][4] 位置。</li>
<li>v_0[][4] 速度。</li>
<li>t_dyn システム時間。破壊計算で質量は減少するのでその見積もり用。</li>
<li>*frag_p 破壊計算に必要なデータをもつ構造体ポインタ。破壊計算で質量は減少するのでその見積もり用。</li>
</ol>
<h2 id="heapsort.c-1">heapsort.c</h2>
<div class="sourceCode"><pre class="sourceCode c:heapsort.c"><code class="sourceCode c"><span class="co">/* ヒープソートを行う */</span>
<span class="dt">void</span> HeapSort(CONST <span class="dt">int</span> NUM_DATA, CONST <span class="dt">double</span> t[], CONST <span class="dt">double</span> dt[], CONST <span class="dt">double</span> t_tmp, <span class="dt">int</span> index[]){

  <span class="dt">int</span> i, n;
  <span class="dt">int</span> leaf, root;
  <span class="dt">double</span> a[NUM_DATA+<span class="dv">1</span>];

  n = NUM_DATA;

  <span class="cf">for</span>(i=<span class="dv">1</span>;i&lt;=n;i++){
    index[i] = i;
    a[i] = t[i] + dt[i] + t_tmp;
  }

  leaf = n;                           <span class="co">/* 初期値は末尾の要素 */</span>
  root = n/<span class="dv">2</span>;                         <span class="co">/* 初期値はその親 */</span>

  <span class="cf">while</span>(root &gt;= <span class="dv">1</span>){                   <span class="co">/* 半順序木を構成 */</span>
    DownHeap(a,index,leaf,root);
    root--;
  }

  <span class="cf">while</span>(leaf &gt;= <span class="dv">1</span>){
    Swap_double(&amp;a[<span class="dv">1</span>],&amp;a[leaf]);      <span class="co">/* 半順序木の根と末尾の要素を交換 */</span>
    Swap_int(&amp;index[<span class="dv">1</span>],&amp;index[leaf]);
    leaf--;                           <span class="co">/* 末尾の要素を半順序木から外す */</span>
    DownHeap(a,index,leaf,<span class="dv">1</span>);         <span class="co">/* 半順序木を再構成する */</span>
  }

  <span class="cf">return</span>;
}</code></pre></div>
<p>配列 a[] に代入した粒子毎の時間とタイムステップの和を、ヒープソートによって小さい順に並べ、並べ終わった時の粒子番号を配列 index[] に代入する。</p>
<ol type="1">
<li>NUM_DATA 要素数。</li>
<li>t[] 粒子毎の時間。</li>
<li>dt[] 粒子毎のタイムステップ。</li>
<li>t_tmp エネルギー計算などを行なって、すべての粒子をそろえた時間。粒子毎の時間を出力する際には、常にこの t_tmp を足す必要がある。</li>
<li>index[] 粒子毎の時間とタイムステップの和を小さい順に並べた粒子番号。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:heapsort.c"><code class="sourceCode c"><span class="co">/* 半順序木 ( ヒープ ) を構成する */</span>
<span class="dt">void</span> DownHeap(<span class="dt">double</span> a[], <span class="dt">int</span> index[], <span class="dt">int</span> leaf, <span class="dt">int</span> root){

  <span class="dt">int</span> i;

  <span class="cf">if</span>(root==<span class="dv">1</span>){
    i = <span class="dv">2</span>;
  }
  <span class="cf">else</span>{
    i = root * <span class="dv">2</span>;
  }
  <span class="cf">while</span>(i &lt;= leaf){
    <span class="cf">if</span>(i &lt; leaf &amp;&amp; a[i+<span class="dv">1</span>] &gt; a[i]){    <span class="co">/* a[i] と a[i+1] の大きい方と */</span>
      i++;
    }
    <span class="cf">if</span>(a[root] &gt;= a[i]){              <span class="co">/* a[root] と比較 */</span>
      <span class="cf">break</span>;                          <span class="co">/* 子の方が大きければ */</span>
    }

    Swap_double(&amp;a[root],&amp;a[i]);      <span class="co">/* 交換 */</span>
    Swap_int(&amp;index[root],&amp;index[i]);
    root = i;                         <span class="co">/* 更にその子についても調べる */</span>
    i = root * <span class="dv">2</span>;
  }

  <span class="cf">return</span>;
}</code></pre></div>
<p>半順序木 ( ヒープ ) を構成。</p>
<ol type="1">
<li>a[] 小さい順に並べ替えたい1次元配列。</li>
<li>index[] a[] の粒子番号。</li>
<li>leaf 末尾。</li>
<li>root 根。</li>
</ol>
<h2 id="massflux.c-1">massflux.c</h2>
<div class="sourceCode"><pre class="sourceCode c:massflux.c"><code class="sourceCode c"><span class="dt">void</span> MassFlux(<span class="dt">int</span> i, CONST <span class="kw">struct</span> orbital_elements *ele_p, <span class="kw">struct</span> fragmentation *frag_p, CONST <span class="kw">struct</span> parameter *para_p){
  <span class="dt">double</span> F;
  <span class="dt">double</span> a_inv = <span class="fl">1.0</span>/((ele_p+i)-&gt;axis);
  <span class="dt">double</span> alpha = (para_p-&gt;alpha);
  <span class="dt">double</span> v = ((frag_p+i)-&gt;v_ave);
  <span class="dt">double</span> sigma = ((frag_p+i)-&gt;sigma);
  <span class="dt">double</span> s_1 = (para_p-&gt;s_1);
  <span class="dt">double</span> s_2 = (para_p-&gt;s_2);
  <span class="dt">double</span> s_3 = (para_p-&gt;s_3);
  <span class="dt">double</span> Q_D = (para_p-&gt;Q_D);
  <span class="dt">double</span> h_0 = (para_p-&gt;h_0);

<span class="pp">#if !defined(G) &amp;&amp; !defined(M_0)</span>
  F = - (<span class="fl">2.0</span> - alpha) * (<span class="fl">2.0</span> - alpha) / cbrt(M_MAX) * sigma * sigma * sqrt(a_inv * a_inv * a_inv) * h_0;
<span class="pp">#else</span>
  F = - (<span class="fl">2.0</span> - alpha) * (<span class="fl">2.0</span> - alpha) / cbrt(M_MAX) * sigma * sigma * sqrt(G * M_0 * a_inv * a_inv * a_inv) * h_0;
<span class="pp">#endif</span>

  F *= pow(v * v * <span class="fl">0.5</span> / Q_D, alpha - <span class="fl">1.0</span>);
  F *= ((- log(EPSILON_FRAG) + <span class="fl">1.0</span> / (<span class="fl">2.0</span>-B_FRAG)) * s_1 + s_2 + s_3);

  ((frag_p+i)-&gt;flux) = F;

  <span class="cf">return</span>;
}</code></pre></div>
<p>衝突カスケードによる質量フラックス計算。</p>
<ol type="1">
<li>i i 粒子。</li>
<li>*ele_p 軌道要素の構造体ポインタ。</li>
<li>*frag_p 破壊計算に必要なデータをもつ構造体ポインタ。</li>
<li>*para_p 破壊計算のパラメータの構造体ポインタ。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:massflux.c"><code class="sourceCode c"><span class="dt">double</span> Depletion_Time(<span class="dt">int</span> i, CONST <span class="kw">struct</span> fragmentation *frag_p){
  <span class="cf">return</span> - XI * ((frag_p+i)-&gt;sigma) / ((frag_p+i)-&gt;flux);
}</code></pre></div>
<p>破壊による質量減少タイムスケールの XI 倍を、破壊計算を行う間隔の目安とする。</p>
<ol type="1">
<li>i i 粒子。</li>
<li>*frag_p 破壊計算に必要なデータをもつ構造体ポインタ。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:massflux.c"><code class="sourceCode c"><span class="dt">double</span> MassDepletion(<span class="dt">int</span> i, <span class="dt">double</span> mass, <span class="dt">double</span> t_dyn, CONST <span class="kw">struct</span> fragmentation *frag_p){
  <span class="dt">double</span> t_frag = ((frag_p+i)-&gt;t_frag);
  <span class="dt">double</span> tau_dep = - ((frag_p+i)-&gt;sigma) / ((frag_p+i)-&gt;flux);
  <span class="cf">if</span>(i &gt; global_n_p &amp;&amp; t_dyn &gt; <span class="fl">1.0E-10</span>){  <span class="co">//惑星でない かつ 初期でない.</span>
    <span class="cf">return</span> mass / (<span class="fl">1.0</span> + (t_dyn - t_frag) / tau_dep);
  }<span class="cf">else</span>
    <span class="cf">return</span> mass;  <span class="co">//惑星の場合は変化させない.</span>
}</code></pre></div>
<p>破壊による質量減少計算。</p>
<ol type="1">
<li>i i 粒子。</li>
<li>mass i 粒子の質量（減少前）。</li>
<li>t_dyn システム時間。</li>
<li>*frag_p 破壊計算に必要なデータをもつ構造体ポインタ。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:massflux.c"><code class="sourceCode c"><span class="pp">#if FRAGMENTATION</span>
<span class="dt">double</span> s_1_FRAG_trapezoid(<span class="dt">int</span> n, <span class="dt">double</span> dx, <span class="dt">double</span> ini, CONST <span class="kw">struct</span> parameter *para_p){
  <span class="cf">return</span> <span class="fl">0.5</span> * dx * (s_1_FRAG_integrand(ini + n * dx, para_p) + s_1_FRAG_integrand(ini + (n + <span class="dv">1</span>) * dx, para_p));
}
<span class="pp">#endif</span>


<span class="pp">#if FRAGMENTATION</span>
<span class="dt">double</span> s_2_FRAG_trapezoid(<span class="dt">int</span> n, <span class="dt">double</span> dx, <span class="dt">double</span> ini, CONST <span class="kw">struct</span> parameter *para_p){
  <span class="cf">return</span> <span class="fl">0.5</span> * dx * (s_2_FRAG_integrand(ini + n * dx, para_p) + s_2_FRAG_integrand(ini + (n + <span class="dv">1</span>) * dx, para_p));
}
<span class="pp">#endif</span>


<span class="pp">#if FRAGMENTATION</span>
<span class="dt">double</span> s_3_FRAG_trapezoid(<span class="dt">int</span> n, <span class="dt">double</span> dx, <span class="dt">double</span> ini, CONST <span class="kw">struct</span> parameter *para_p){
  <span class="cf">return</span> <span class="fl">0.5</span> * dx * (s_3_FRAG_integrand(ini + n * dx, para_p) + s_3_FRAG_integrand(ini + (n + <span class="dv">1</span>) * dx, para_p));
}
<span class="pp">#endif</span>


<span class="pp">#if FRAGMENTATION</span>
<span class="dt">double</span> s_1_FRAG_integrand(<span class="dt">double</span> x, CONST <span class="kw">struct</span> parameter *para_p){
  <span class="cf">return</span> exp((<span class="fl">2.0</span> - (para_p-&gt;alpha)) * x) / (<span class="fl">1.0</span> + exp(x));
}
<span class="pp">#endif</span>


<span class="pp">#if FRAGMENTATION</span>
<span class="dt">double</span> s_2_FRAG_integrand(<span class="dt">double</span> x, CONST <span class="kw">struct</span> parameter *para_p){
  <span class="cf">return</span> - exp((<span class="fl">2.0</span> - (para_p-&gt;alpha)) * x) / (<span class="fl">1.0</span> + exp(x)) * (x - <span class="fl">2.0</span> * log(<span class="dv">1</span> + exp(x)));
}
<span class="pp">#endif</span>


<span class="pp">#if FRAGMENTATION</span>
<span class="dt">double</span> s_3_FRAG_integrand(<span class="dt">double</span> x, CONST <span class="kw">struct</span> parameter *para_p){
  <span class="cf">return</span> exp((<span class="fl">1.0</span> - (para_p-&gt;alpha)) * x) / (<span class="fl">1.0</span> + exp(x)) * log(<span class="fl">1.0</span> + exp(x));
}
<span class="pp">#endif</span>


<span class="pp">#if FRAGMENTATION</span>
<span class="dt">double</span> s_1_FRAG(<span class="kw">struct</span> parameter *para_p){
  <span class="dt">int</span> n, n_max;
  <span class="dt">double</span> dx, sum=<span class="fl">0.0</span>, sum_pre=<span class="fl">0.0</span>;
  <span class="dt">double</span> ini=-<span class="fl">36.0</span>, fin=<span class="fl">36.0</span>;
  <span class="dt">double</span> eps=<span class="fl">1.0E-7</span>;

  n_max = <span class="dv">1</span>;
  <span class="cf">do</span>{
    dx = (fin - ini) / (<span class="dt">double</span>)n_max;
    sum_pre = sum;
    sum=<span class="dv">0</span>;
    <span class="cf">for</span>(n=<span class="dv">0</span>;n&lt;n_max;n++){
      sum += s_1_FRAG_trapezoid(n, dx, ini, para_p);
    }
    <span class="co">//fprintf(fplog,&quot;n_max=%d\n&quot;,n_max);</span>
    n_max *= <span class="dv">2</span>;
  }<span class="cf">while</span>(fabs(sum_pre-sum)&gt;eps);

  <span class="cf">return</span> sum;
}
<span class="pp">#endif</span>


<span class="pp">#if FRAGMENTATION</span>
<span class="dt">double</span> s_2_FRAG(<span class="kw">struct</span> parameter *para_p){
  <span class="dt">int</span> n, n_max;
  <span class="dt">double</span> dx, sum=<span class="fl">0.0</span>, sum_pre=<span class="fl">0.0</span>;
  <span class="dt">double</span> ini=-<span class="fl">36.0</span>, fin=<span class="fl">36.0</span>;
  <span class="dt">double</span> eps=<span class="fl">1.0E-7</span>;

  n_max = <span class="dv">1</span>;
  <span class="cf">do</span>{
    dx = (fin - ini) / (<span class="dt">double</span>)n_max;
    sum_pre = sum;
    sum=<span class="dv">0</span>;
    <span class="cf">for</span>(n=<span class="dv">0</span>;n&lt;n_max;n++){
      sum += s_2_FRAG_trapezoid(n, dx, ini, para_p);
    }
    <span class="co">//fprintf(fplog,&quot;n_max=%d\n&quot;,n_max);</span>
    n_max *= <span class="dv">2</span>;
  }<span class="cf">while</span>(fabs(sum_pre-sum)&gt;eps);

  <span class="cf">return</span> sum;
}
<span class="pp">#endif</span>


<span class="pp">#if FRAGMENTATION</span>
<span class="dt">double</span> s_3_FRAG(<span class="kw">struct</span> parameter *para_p){
  <span class="dt">int</span> n, n_max;
  <span class="dt">double</span> dx,sum=<span class="fl">0.0</span>, sum_pre=<span class="fl">0.0</span>;
  <span class="dt">double</span> ini=-<span class="fl">36.0</span>, fin=<span class="fl">36.0</span>;
  <span class="dt">double</span> eps=<span class="fl">1.0E-7</span>;

  n_max = <span class="dv">1</span>;
  <span class="cf">do</span>{
    dx = (fin - ini) / (<span class="dt">double</span>)n_max;
    sum_pre = sum;
    sum=<span class="dv">0</span>;
    <span class="cf">for</span>(n=<span class="dv">0</span>;n&lt;n_max;n++){
      sum += s_3_FRAG_trapezoid(n, dx, ini, para_p);
    }
    <span class="co">//fprintf(fplog,&quot;n_max=%d\n&quot;,n_max);</span>
    n_max *= <span class="dv">2</span>;
  }<span class="cf">while</span>(fabs(sum_pre-sum)&gt;eps);

  <span class="cf">return</span> sum;
}
<span class="pp">#endif</span></code></pre></div>
<p>質量フラックスを求める際に必要なパラメータ（<span class="math inline"><em>s</em><sub>1</sub>(<em>α</em>),<em>s</em><sub>2</sub>(<em>α</em>),<em>s</em><sub>3</sub>(<em>α</em>)</span>）を、計算の初期設定の段階で数値積分で求めておく。</p>
<h2 id="neighbor.c-1">neighbor.c</h2>
<div class="sourceCode"><pre class="sourceCode c:neighbor.c"><code class="sourceCode c"><span class="dt">void</span> NeighborSearch(<span class="dt">int</span> i, <span class="dt">double</span> t_dyn, CONST <span class="kw">struct</span> orbital_elements *ele_p, <span class="kw">struct</span> fragmentation *frag_p, CONST <span class="dt">double</span> x_0[][<span class="dv">4</span>]){

  <span class="dt">int</span> j,l,m;
  <span class="dt">double</span> radius[global_n+<span class="dv">1</span>];
  <span class="dt">double</span> theta[global_n+<span class="dv">1</span>];
  <span class="dt">double</span> S;
  <span class="dt">double</span> M;
  <span class="dt">double</span> v2;
  <span class="dt">double</span> delta_theta=DELTA_THETA;


  radius[i] = sqrt(x_0[i][<span class="dv">1</span>]*x_0[i][<span class="dv">1</span>] + x_0[i][<span class="dv">2</span>]*x_0[i][<span class="dv">2</span>]);
  theta[i] = atan2(x_0[i][<span class="dv">2</span>],x_0[i][<span class="dv">1</span>]);  <span class="co">//[-pi:pi]</span>

  <span class="cf">if</span>(i&lt;=global_n_p){
    fprintf(fplog,<span class="st">&quot;i = %d, global_n_p = %d</span><span class="sc">\n</span><span class="st">&quot;</span>,i,global_n_p);
  }

  m = <span class="dv">1</span>;
  <span class="cf">do</span>{

    <span class="cf">for</span>(l=<span class="dv">1</span>;l&lt;=NEIGHBOR_MAX;l++){
      ((frag_p+i)-&gt;neighborlist[l]) = <span class="dv">0</span>;
    }
    ((frag_p+i)-&gt;neighbornumber) = <span class="dv">0</span>;

    ((frag_p+i)-&gt;delta_r_out) = (<span class="dt">double</span>)m * DELTA_R;  <span class="co">//外側.</span>
    ((frag_p+i)-&gt;delta_r_in) = (<span class="dt">double</span>)m * DELTA_R;  <span class="co">//内側.</span>

    S = <span class="fl">2.0</span> * (((frag_p+i)-&gt;delta_r_out) + ((frag_p+i)-&gt;delta_r_in)) * radius[i] * delta_theta;

    <span class="co">//fprintf(fplog,&quot;i=%d\tS=%e\n&quot;,i,S);</span>
    <span class="co">//fprintf(fplog,&quot;delta_r[%d]=%f\n&quot;,i,((frag_p+i)-&gt;delta_r_in));</span>

    l = <span class="dv">1</span>;
    <span class="cf">for</span>(j=global_n_p+<span class="dv">1</span>;j&lt;=global_n;j++){  <span class="co">//惑星抜き.</span>
      <span class="cf">if</span>(j!=i){
        radius[j] = sqrt(x_0[j][<span class="dv">1</span>]*x_0[j][<span class="dv">1</span>] + x_0[j][<span class="dv">2</span>]*x_0[j][<span class="dv">2</span>]);
        theta[j] = atan2(x_0[j][<span class="dv">2</span>],x_0[j][<span class="dv">1</span>]);  <span class="co">//[-pi:pi]</span>
    <span class="cf">if</span>((radius[j]-radius[i]&gt;=<span class="fl">0.0</span> &amp;&amp; radius[j]-radius[i]&lt;=((frag_p+i)-&gt;delta_r_out)) || (radius[i]-radius[j]&gt;=<span class="fl">0.0</span> &amp;&amp; radius[i]-radius[j]&lt;=((frag_p+i)-&gt;delta_r_in))){  <span class="co">//動径方向.</span>
      <span class="cf">if</span>(fabs(theta[j] - theta[i])&lt;=delta_theta || <span class="fl">2.0</span>*M_PI - fabs(theta[j] - theta[i])&lt;=delta_theta){  <span class="co">//角度方向.</span>
        ((frag_p+i)-&gt;neighborlist[l]) = j;
        l++;
      }
    }
      }
    }

    <span class="cf">if</span>(NEIGHBOR_MAX &lt; l-<span class="dv">1</span>){
      fprintf(fplog,<span class="st">&quot;neighbornumber (%d) &gt; NEIGHBOR_MAX (%d). Ending this program.</span><span class="sc">\n</span><span class="st">&quot;</span>,l-<span class="dv">1</span>,NEIGHBOR_MAX);
      exit(-<span class="dv">1</span>);
    }

    ((frag_p+i)-&gt;neighbornumber) = l-<span class="dv">1</span>;

    m++;

    <span class="co">//}while(((frag_p+i)-&gt;neighbornumber)&lt;10);  //近傍粒子が10個未満なら、10個以上になるまでdelta_rをm倍に広げる.</span>
  }<span class="cf">while</span>(((frag_p+i)-&gt;neighbornumber)&lt;<span class="dv">10</span> &amp;&amp; m&lt;<span class="dv">10</span>);  <span class="co">//近傍粒子が10個未満 かつ delta_r &lt; 1.0 なら、1個以上になるまでdelta_rをm倍に広げる.</span>

  v2 = <span class="fl">0.0</span>;

  M = MassDepletion(i,((ele_p+i)-&gt;mass),t_dyn,frag_p);  <span class="co">//ターゲットiの質量も含める. 予測もする.</span>

  <span class="cf">if</span>(((frag_p+i)-&gt;neighbornumber)!=<span class="dv">0</span>){
    <span class="cf">for</span>(j=<span class="dv">1</span>;j&lt;=((frag_p+i)-&gt;neighbornumber);j++){
      v2 += SquareRandomVelocity(i,((frag_p+i)-&gt;neighborlist[j]),ele_p);

      M += MassDepletion(((frag_p+i)-&gt;neighborlist[j]),((ele_p+((frag_p+i)-&gt;neighborlist[j]))-&gt;mass),t_dyn,frag_p);  <span class="co">//領域iの総質量. 周りのトレーサーjの質量を予測してから足す.</span>

      <span class="cf">if</span>(isnan(SquareRandomVelocity(i,((frag_p+i)-&gt;neighborlist[j]),ele_p))){
        fprintf(fplog,<span class="st">&quot;i=%d,j=%d</span><span class="sc">\t</span><span class="st">vij is nan.</span><span class="sc">\n</span><span class="st">&quot;</span>,i,((frag_p+i)-&gt;neighborlist[j]));
        fprintf(fplog,<span class="st">&quot;i=%d</span><span class="sc">\t</span><span class="st">axis=%e</span><span class="sc">\t</span><span class="st">ecc=%e</span><span class="sc">\t</span><span class="st">inc=%e</span><span class="sc">\t</span><span class="st">u=%e</span><span class="sc">\t</span><span class="st">Omega=%e</span><span class="sc">\t</span><span class="st">omega=%e</span><span class="sc">\n</span><span class="st">&quot;</span>,i,((ele_p+i)-&gt;axis),((ele_p+i)-&gt;ecc),((ele_p+i)-&gt;inc),((ele_p+i)-&gt;u),((ele_p+i)-&gt;Omega),((ele_p+i)-&gt;omega));
        fprintf(fplog,<span class="st">&quot;j=%d</span><span class="sc">\t</span><span class="st">axis=%e</span><span class="sc">\t</span><span class="st">ecc=%e</span><span class="sc">\t</span><span class="st">inc=%e</span><span class="sc">\t</span><span class="st">u=%e</span><span class="sc">\t</span><span class="st">Omega=%e</span><span class="sc">\t</span><span class="st">omega=%e</span><span class="sc">\n</span><span class="st">&quot;</span>,((frag_p+i)-&gt;neighborlist[j]),((ele_p+((frag_p+i)-&gt;neighborlist[j]))-&gt;axis),((ele_p+((frag_p+i)-&gt;neighborlist[j]))-&gt;ecc),((ele_p+((frag_p+i)-&gt;neighborlist[j]))-&gt;inc),((ele_p+((frag_p+i)-&gt;neighborlist[j]))-&gt;u),((ele_p+((frag_p+i)-&gt;neighborlist[j]))-&gt;Omega),((ele_p+((frag_p+i)-&gt;neighborlist[j]))-&gt;omega));
      }

    }
    <span class="cf">if</span>(isnan(v2)){
      fprintf(fplog,<span class="st">&quot;i=%d</span><span class="sc">\t</span><span class="st">v_tot_2 is nan.</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
    }
    ((frag_p+i)-&gt;v_ave) = sqrt(v2/(<span class="dt">double</span>)((frag_p+i)-&gt;neighbornumber));  <span class="co">//領域iの平均速度(RMS).</span>

    <span class="co">//fprintf(fplog,&quot;i=%d\tmass=%e\n&quot;,i,ele[i].mass);</span>
    <span class="co">//fprintf(fplog,&quot;i=%d\tM=%e\n&quot;,i,M);</span>

    ((frag_p+i)-&gt;sigma) = M / S;  <span class="co">//領域iの表面密度.</span>
    ((frag_p+i)-&gt;n_s) = ((frag_p+i)-&gt;neighbornumber) / S;  <span class="co">//領域iの個数密度.</span>
  }<span class="cf">else</span>{
    fprintf(fplog,<span class="st">&quot;t_sys = %e [yr]</span><span class="sc">\t</span><span class="st">i = %d</span><span class="sc">\t</span><span class="st">neighbor number = %d</span><span class="sc">\t</span><span class="st">v_ave, sigma, &amp; n_s does NOT change.</span><span class="sc">\n</span><span class="st">&quot;</span>,t_dyn/<span class="fl">2.0</span>/M_PI,i,((frag_p+i)-&gt;neighbornumber));
    <span class="co">//((frag_p+i)-&gt;v_ave) = 0.0;</span>
    <span class="co">//((frag_p+i)-&gt;sigma) = 0.0;</span>
    <span class="co">//((frag_p+i)-&gt;n_s) = 0.0;</span>
  }

  <span class="cf">return</span>;
}</code></pre></div>
<p>トレーサーの周りに扇型領域を形成し、その領域に入った近傍のトレーサーから、相対速度の2乗平均平方根、面密度、面数密度を計算する。</p>
<ol type="1">
<li>i i 粒子。</li>
<li>t_dyn システム粒子。</li>
<li>*ele_p 軌道要素の構造体ポインタ。</li>
<li>*frag_p 破壊計算に必要なデータをもつ構造体ポインタ。</li>
<li>x_0[][4] 位置。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:neighbor.c"><code class="sourceCode c"><span class="dt">double</span> SquareRandomVelocity(<span class="dt">int</span> i, <span class="dt">int</span> j, CONST <span class="kw">struct</span> orbital_elements *ele_p){
  <span class="dt">double</span> eij2;
  <span class="dt">double</span> iij2;

  eij2 = ((ele_p+i)-&gt;ecc) * ((ele_p+i)-&gt;ecc) + ((ele_p+j)-&gt;ecc) * ((ele_p+j)-&gt;ecc) - <span class="fl">2.0</span> * ((ele_p+i)-&gt;ecc) * ((ele_p+j)-&gt;ecc) * cos(((ele_p+i)-&gt;omega) + ((ele_p+i)-&gt;Omega) - ((ele_p+j)-&gt;omega) - ((ele_p+j)-&gt;Omega));

  iij2 = ((ele_p+i)-&gt;inc) * ((ele_p+i)-&gt;inc) + ((ele_p+j)-&gt;inc) * ((ele_p+j)-&gt;inc) - <span class="fl">2.0</span> * ((ele_p+i)-&gt;inc) * ((ele_p+j)-&gt;inc) * cos(((ele_p+i)-&gt;Omega) - ((ele_p+j)-&gt;Omega));


  <span class="co">/*</span>
<span class="co">  if(isnan((ele_p+i)-&gt;ecc)){</span>
<span class="co">    fprintf(fplog,&quot;i=%d\tecc is nan. (in RandomVelocity)\n&quot;,i);</span>
<span class="co">  }</span>
<span class="co">  if(isnan((ele_p+j)-&gt;ecc)){</span>
<span class="co">    fprintf(fplog,&quot;j=%d\tecc is nan. (in RandomVelocity)\n&quot;,j);</span>
<span class="co">  }</span>
<span class="co">  if(isnan((ele_p+i)-&gt;inc)){</span>
<span class="co">    fprintf(fplog,&quot;i=%d\tinc is nan. (in RandomVelocity).\n&quot;,i);</span>
<span class="co">  }</span>
<span class="co">  if(isnan((ele_p+j)-&gt;inc)){</span>
<span class="co">    fprintf(fplog,&quot;j=%d\tinc is nan. (in RandomVelocity)\n&quot;,j);</span>
<span class="co">  }</span>
<span class="co">  if(isnan((ele_p+i)-&gt;omega)){</span>
<span class="co">    fprintf(fplog,&quot;i=%d\tomega is nan. (in RandomVelocity)\n&quot;,i);</span>
<span class="co">  }</span>
<span class="co">  if(isnan((ele_p+j)-&gt;omega)){</span>
<span class="co">    fprintf(fplog,&quot;j=%d\tomega is nan. (in RandomVelocity)\n&quot;,j);</span>
<span class="co">  }</span>
<span class="co">  if(isnan((ele_p+i)-&gt;Omega)){</span>
<span class="co">    fprintf(fplog,&quot;i=%d\tOmega is nan. (in RandomVelocity)\n&quot;,i);</span>
<span class="co">  }</span>
<span class="co">  if(isnan((ele_p+j)-&gt;Omega)){</span>
<span class="co">    fprintf(fplog,&quot;j=%d\tOmega is nan. (in RandomVelocity)\n&quot;,j);</span>
<span class="co">  }</span>
<span class="co">  if(isnan(eij2)){</span>
<span class="co">    fprintf(fplog,&quot;i=%d,j=%d\teij2 is nan. (in RandomVelocity)\n&quot;,i,j);</span>
<span class="co">    return -1;</span>
<span class="co">  }</span>
<span class="co">  if(isnan(iij2)){</span>
<span class="co">    fprintf(fplog,&quot;i=%d,j=%d\tiij2 is nan. (in RandomVelocity)\n&quot;,i,j);</span>
<span class="co">    return -1;</span>
<span class="co">  }</span>
<span class="co">  if(isnan((ele_p+i)-&gt;axis)){</span>
<span class="co">    fprintf(fplog,&quot;i=%d\taxis is nan. (in RandomVelocity)\taxis=%f\n&quot;,i,((ele_p+i)-&gt;axis));</span>
<span class="co">  }</span>
<span class="co">  */</span>

  <span class="cf">if</span>(
<span class="pp">#if !defined(G) &amp;&amp; !defined(M_0)</span>
     isnan(sqrt((eij2 + iij2)/((ele_p+i)-&gt;axis)))
<span class="pp">#else</span>
     isnan(sqrt((eij2 + iij2)*G*M_0/((ele_p+i)-&gt;axis)))
<span class="pp">#endif</span>
     ){
    fprintf(fplog,<span class="st">&quot;i=%d,j=%d</span><span class="sc">\t</span><span class="st">vij is nan.(in RandomVelocity)</span><span class="sc">\n</span><span class="st">&quot;</span>,i,j);
    fprintf(fplog,<span class="st">&quot;eij2=%e</span><span class="sc">\t</span><span class="st">iij2=%e</span><span class="sc">\t</span><span class="st">axis=%e</span><span class="sc">\n</span><span class="st">&quot;</span>,eij2,iij2,((ele_p+i)-&gt;axis));
  }


<span class="pp">#if !defined(G) &amp;&amp; !defined(M_0)</span>
  <span class="cf">return</span> (eij2 + iij2) / ((ele_p+i)-&gt;axis);
<span class="pp">#else</span>
  <span class="cf">return</span> (eij2 + iij2) * G * M_0 / ((ele_p+i)-&gt;axis);
<span class="pp">#endif</span>
}</code></pre></div>
<p>相対速度の大きさの2乗を、相対離心率と相対軌道傾斜角から求める。</p>
<ol type="1">
<li>i i 粒子。</li>
<li>j j 粒子。</li>
<li>*ele_p 軌道要素の構造体ポインタ。</li>
</ol>
<h2 id="orbital_elements.c-1">orbital_elements.c</h2>
<div class="sourceCode"><pre class="sourceCode c:orbital_elements.c"><code class="sourceCode c"><span class="co">/*P計算*/</span>
<span class="dt">double</span> Calculate_P(<span class="dt">int</span> i, <span class="dt">int</span> k, CONST <span class="kw">struct</span> orbital_elements *ele_p){
  <span class="cf">if</span>(k==<span class="dv">1</span>){
    <span class="cf">return</span> cos(((ele_p+i)-&gt;omega))*cos(((ele_p+i)-&gt;Omega)) - sin(((ele_p+i)-&gt;omega))*sin(((ele_p+i)-&gt;Omega))*cos(((ele_p+i)-&gt;inc));
  }<span class="cf">else</span> <span class="cf">if</span>(k==<span class="dv">2</span>){
    <span class="cf">return</span> cos(((ele_p+i)-&gt;omega))*sin(((ele_p+i)-&gt;Omega)) + sin(((ele_p+i)-&gt;omega))*cos(((ele_p+i)-&gt;Omega))*cos(((ele_p+i)-&gt;inc));
  }<span class="cf">else</span>{
    <span class="cf">return</span> sin(((ele_p+i)-&gt;omega))*sin(((ele_p+i)-&gt;inc));
  }
}


<span class="co">/*Q計算*/</span>
<span class="dt">double</span> Calculate_Q(<span class="dt">int</span> i, <span class="dt">int</span> k, CONST <span class="kw">struct</span> orbital_elements *ele_p){
  <span class="cf">if</span>(k==<span class="dv">1</span>){
    <span class="cf">return</span> -sin(((ele_p+i)-&gt;omega))*cos(((ele_p+i)-&gt;Omega)) - cos(((ele_p+i)-&gt;omega))*sin(((ele_p+i)-&gt;Omega))*cos(((ele_p+i)-&gt;inc));
  }<span class="cf">else</span> <span class="cf">if</span>(k==<span class="dv">2</span>){
    <span class="cf">return</span> -sin(((ele_p+i)-&gt;omega))*sin(((ele_p+i)-&gt;Omega)) + cos(((ele_p+i)-&gt;omega))*cos(((ele_p+i)-&gt;Omega))*cos(((ele_p+i)-&gt;inc));
  }<span class="cf">else</span>{
    <span class="cf">return</span> cos(((ele_p+i)-&gt;omega))*sin(((ele_p+i)-&gt;inc));
  }
}</code></pre></div>
<p>軌道要素から位置・速度への変換に使うPとQを計算。</p>
<p><span class="math inline">$\boldsymbol { P } = \left( \begin{array} { c } { P _ { x } } \\ { P _ { y } } \\ { P _ { z } } \end{array} \right) \equiv \left( \begin{array} { c } { \cos \omega \cos \Omega - \sin \omega \sin \Omega \cos i } \\ { \cos \omega \sin \Omega + \sin \omega \cos \Omega \cos i } \\ { \sin \omega \sin i } \end{array} \right)$</span></p>
<p><span class="math inline">$\boldsymbol { Q } = \left( \begin{array} { c } { Q _ { x } } \\ { Q _ { y } } \\ { Q _ { z } } \end{array} \right) \equiv \left( \begin{array} { c } { - \sin \omega \cos \Omega - \cos \omega \sin \Omega \cos i } \\ { - \sin \omega \sin \Omega + \cos \omega \cos \Omega \cos i } \\ { \cos \omega \sin i } \end{array} \right)$</span></p>
<ol type="1">
<li>i i 粒子。</li>
<li>k ベクトル3成分。</li>
<li>*ele_p 軌道要素の構造体ポインタ。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:orbital_elements.c"><code class="sourceCode c"><span class="co">/*惑星の初期軌道要素*/</span>
<span class="dt">void</span> InitialOrbitalElements_Planet(<span class="dt">int</span> i,<span class="kw">struct</span> orbital_elements *ele_p){

  sprintf((ele_p+i)-&gt;name,<span class="st">&quot;Planet%02d&quot;</span>,i);
  (ele_p+i)-&gt;mass = PLANET_MASS;
  <span class="co">//(ele_p+i)-&gt;axis = PLANET_AXIS;  //軌道長半径axisはすでに求めてある.</span>
  (ele_p+i)-&gt;ecc = PLANET_ECC;
  (ele_p+i)-&gt;inc = PLANET_INC;
  (ele_p+i)-&gt;u = rand_func() * <span class="fl">2.0</span> * M_PI;
  (ele_p+i)-&gt;omega = rand_func() * <span class="fl">2.0</span> * M_PI;
  (ele_p+i)-&gt;Omega = rand_func() * <span class="fl">2.0</span> * M_PI;

<span class="pp">#ifndef M_0</span>
  (ele_p+i)-&gt;r_h = ((ele_p+i)-&gt;axis)*cbrt(((ele_p+i)-&gt;mass)/<span class="fl">3.0</span>);
<span class="pp">#else</span>
  (ele_p+i)-&gt;r_h = ((ele_p+i)-&gt;axis)*cbrt(((ele_p+i)-&gt;mass)/M_0/<span class="fl">3.0</span>);
<span class="pp">#endif</span>

  (ele_p+i)-&gt;radius = cbrt(<span class="fl">3.0</span>/<span class="fl">4.0</span>/M_PI*((ele_p+i)-&gt;mass)*<span class="fl">1.989E33</span>/PLANET_DENSITY)/<span class="fl">1.496E13</span>;
  (ele_p+i)-&gt;orinum = i;

  <span class="cf">return</span>;
}</code></pre></div>
<p>惑星の初期軌道要素を設定。 hybrid.h 内でパラメータを決定する。</p>
<ol type="1">
<li>i i 粒子。</li>
<li>*ele_p 軌道要素の構造体ポインタ。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:orbital_elements.c"><code class="sourceCode c"><span class="pp">#if ORBITING_SMALL_PARTICLE</span>
<span class="co">/*トレーサーの初期軌道要素*/</span>
<span class="dt">void</span> InitialOrbitalElements_Tracer(<span class="dt">int</span> i, <span class="dt">double</span> x_0[][<span class="dv">4</span>], <span class="kw">struct</span> orbital_elements *ele_p){

  <span class="co">//惑星の位置x_0[][4]はすでに求めてあることが前提.</span>
<span class="pp">#if N_p == 3</span>
  <span class="dt">double</span> orbital_r_min = ((ele_p+<span class="dv">1</span>)-&gt;axis) / MutualHillRadius_to_SemimajorAxis(<span class="fl">0.5</span>*DELTA_HILL);
  <span class="dt">double</span> orbital_r_max = ((ele_p+<span class="dv">3</span>)-&gt;axis) * MutualHillRadius_to_SemimajorAxis(<span class="fl">0.5</span>*DELTA_HILL);
<span class="pp">#elif N_p == 1</span>
  <span class="dt">double</span> orbital_r_min = ((ele_p+<span class="dv">1</span>)-&gt;axis) / MutualHillRadius_to_SemimajorAxis(<span class="fl">0.5</span>*DELTA_HILL);
  <span class="dt">double</span> orbital_r_max = ((ele_p+<span class="dv">1</span>)-&gt;axis) * MutualHillRadius_to_SemimajorAxis(<span class="fl">0.5</span>*DELTA_HILL);
<span class="pp">#endif</span>

  <span class="dt">int</span> j=<span class="dv">0</span>,k=<span class="dv">0</span>,flag=<span class="dv">0</span>;
  <span class="co">//double peri=0.0,apo=0.0;</span>
  <span class="dt">double</span> orbital_r=<span class="fl">0.0</span>;

  <span class="co">//double index = 0.5;  //f(x) = C x^{-p}.</span>

  sprintf((ele_p+i)-&gt;name,<span class="st">&quot;tracer%06d&quot;</span>,i-global_n_p);
  (ele_p+i)-&gt;mass = M_TOT/(<span class="dt">double</span>)(global_n-global_n_p);  <span class="co">//質量.</span>

  <span class="cf">do</span>{
    flag = <span class="dv">0</span>;

    (ele_p+i)-&gt;axis = rand_func() * (orbital_r_max - orbital_r_min) + orbital_r_min;  <span class="co">//面密度がa^{-1}に比例する分布. ==&gt; 面数密度が一様.</span>
    <span class="co">//(ele_p+i)-&gt;axis = pow((pow(orbital_r_max,1.0-index) - pow(orbital_r_min,1.0-index)) * rand_func() + pow(orbital_r_min,1.0-index), 1.0/(1.0-index));  //べき分布.</span>

<span class="pp">#if RAYLEIGH_DISTRIBUTION</span>
    (ele_p+i)-&gt;ecc = sqrt(-log(rand_func())) * ECC_RMS;  <span class="co">//離心率.  //Rayleigh分布.</span>
    (ele_p+i)-&gt;inc = sqrt(-log(rand_func())) * INC_RMS;  <span class="co">//軌道傾斜角.  //Rayleigh分布.</span>
<span class="pp">#else</span>
    (ele_p+i)-&gt;ecc = ECC_RMS;  <span class="co">//離心率.</span>
    (ele_p+i)-&gt;inc = INC_RMS;  <span class="co">//軌道傾斜角.</span>
<span class="pp">#endif</span>
    (ele_p+i)-&gt;u = rand_func() * <span class="fl">2.0</span> * M_PI;
    (ele_p+i)-&gt;omega = rand_func() * <span class="fl">2.0</span> * M_PI;
    (ele_p+i)-&gt;Omega = rand_func() * <span class="fl">2.0</span> * M_PI;

    <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){
      x_0[i][k] = ((ele_p+i)-&gt;axis) * Calculate_P(i,k,ele_p) * (cos(((ele_p+i)-&gt;u)) - ((ele_p+i)-&gt;ecc)) + ((ele_p+i)-&gt;axis) * sqrt(<span class="fl">1.0</span> - ((ele_p+i)-&gt;ecc) * ((ele_p+i)-&gt;ecc)) * Calculate_Q(i,k,ele_p) * sin(((ele_p+i)-&gt;u));
    }

    <span class="co">//peri = ((ele_p+i)-&gt;axis)*(1.0 - (ele_p+i)-&gt;ecc);</span>
    <span class="co">//apo = ((ele_p+i)-&gt;axis)*(1.0 + (ele_p+i)-&gt;ecc);</span>
    orbital_r = RadiusFromCenter(i,x_0);

    <span class="cf">if</span>(orbital_r &gt; orbital_r_min &amp;&amp; orbital_r &lt; orbital_r_max){  <span class="co">//orbital_r_minからorbital_r_maxの範囲にいる場合.</span>

      <span class="cf">for</span>(j=<span class="dv">1</span>;j&lt;=global_n_p;++j){
        <span class="cf">if</span>(i!=j){
          <span class="cf">if</span>(RelativeDistance(i,j,x_0)&gt;SEPARATE_HILL*((ele_p+j)-&gt;r_h)){  <span class="co">//それぞれの惑星からSEPARATE_HILLヒル以上離れている場合.</span>
            flag += <span class="dv">1</span>;
          }
        }
      }
    }
  }<span class="cf">while</span>(flag &lt; global_n_p);  <span class="co">//orbital_r_minからorbital_r_maxの範囲にいる場合，かつglobal_n_p個の全ての惑星からSEPARATE_HILLヒル以上離れている場合のみ抜け出せるループ.</span>


<span class="pp">#ifndef M_0</span>
  (ele_p+i)-&gt;r_h = ((ele_p+i)-&gt;axis) * cbrt(((ele_p+i)-&gt;mass) / <span class="fl">3.0</span>);
<span class="pp">#else</span>
  (ele_p+i)-&gt;r_h = ((ele_p+i)-&gt;axis) * cbrt(((ele_p+i)-&gt;mass) / M_0 / <span class="fl">3.0</span>);
<span class="pp">#endif</span>

  (ele_p+i)-&gt;radius = cbrt(<span class="fl">3.0</span> / <span class="fl">4.0</span> / M_PI * ((ele_p+i)-&gt;mass) * <span class="fl">1.989E33</span> / PLANET_DENSITY) / <span class="fl">1.496E13</span>;
  (ele_p+i)-&gt;orinum = i;

  <span class="cf">return</span>;
}
<span class="pp">#endif  </span><span class="co">/*ORBITING_SMALL_PARTICLE*/</span></code></pre></div>
<p>トレーサーを初期に円盤状に分布させる場合の初期軌道要素。 hybrid.h 内でパラメータを決定する。</p>
<ol type="1">
<li>i i 粒子。</li>
<li>x_0[][4] 位置。惑星からある程度離れたところに粒子を配置するため、惑星からの距離を測定しながら軌道要素を決定する。</li>
<li>*ele_p 軌道要素の構造体ポインタ。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:orbital_elements.c"><code class="sourceCode c"><span class="co">/*軌道要素計算*/</span>
<span class="dt">void</span> Calculate_OrbitalElements(<span class="dt">int</span> i, CONST <span class="dt">double</span> x_c[][<span class="dv">4</span>], CONST <span class="dt">double</span> v_c[][<span class="dv">4</span>], <span class="kw">struct</span> orbital_elements *ele_p, CONST <span class="dt">double</span> r_c[], CONST <span class="dt">double</span> v2_c[], CONST <span class="dt">double</span> r_dot_v[]
<span class="pp">#if FRAGMENTATION</span>
                   , <span class="dt">double</span> t_dyn
                   , CONST <span class="kw">struct</span> fragmentation *frag_p
<span class="pp">#endif</span>
                   ){


  <span class="dt">double</span> m_i;

<span class="pp">#if FRAGMENTATION</span>
  m_i = MassDepletion(i,((ele_p+i)-&gt;mass),t_dyn,frag_p);
<span class="pp">#else</span>
  m_i = ((ele_p+i)-&gt;mass);
<span class="pp">#endif</span>


<span class="pp">#if INDIRECT_TERM</span>

<span class="pp">#if !defined(G) &amp;&amp; !defined(M_0)</span>
  <span class="dt">double</span> mu = <span class="fl">1.0</span> + m_i;
<span class="pp">#else</span>
  <span class="dt">double</span> mu = G * (M_0 + m_i);
<span class="pp">#endif</span>

<span class="pp">#else</span>

<span class="pp">#if !defined(G) &amp;&amp; !defined(M_0)</span>
  <span class="dt">double</span> mu = <span class="fl">1.0</span>;
<span class="pp">#else</span>
  <span class="dt">double</span> mu = G * M_0;
<span class="pp">#endif</span>

<span class="pp">#endif</span>

  <span class="dt">int</span> k;
  <span class="dt">double</span> esin_u;
  <span class="dt">double</span> ecos_u;
  <span class="dt">double</span> sin_inc;
  <span class="dt">double</span> cos_inc;
  <span class="dt">double</span> sin_omega;
  <span class="dt">double</span> cos_omega;
  <span class="dt">double</span> sin_Omega;
  <span class="dt">double</span> cos_Omega;
  <span class="dt">double</span> radian;
  <span class="dt">static</span> <span class="dt">double</span> P[N_p+N_tr+<span class="dv">1</span>][<span class="dv">4</span>]={}, Q[N_p+N_tr+<span class="dv">1</span>][<span class="dv">4</span>]={};


  ((ele_p+i)-&gt;axis) = <span class="fl">1.0</span> / (<span class="fl">2.0</span> / r_c[i] - v2_c[i] / mu);


  <span class="cf">if</span>(isnan((ele_p+i)-&gt;axis)){
    fprintf(fplog,<span class="st">&quot;i=%d</span><span class="sc">\t</span><span class="st">axis is nan.</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
  }


  <span class="cf">if</span>(((ele_p+i)-&gt;axis)&lt;<span class="fl">0.0</span>){
    fprintf(fplog,<span class="st">&quot;i=%d</span><span class="sc">\t</span><span class="st">axis=%e &lt; 0 hyperbola orbit.</span><span class="sc">\n</span><span class="st">&quot;</span>,i,((ele_p+i)-&gt;axis));
    <span class="co">/*</span>
<span class="co">    ((ele_p+i)-&gt;ecc) = NAN;</span>
<span class="co">    ((ele_p+i)-&gt;u) = NAN;</span>
<span class="co">    ((ele_p+i)-&gt;inc) = NAN;</span>
<span class="co">    ((ele_p+i)-&gt;omega) = NAN;</span>
<span class="co">    ((ele_p+i)-&gt;Omega) = NAN;</span>
<span class="co">    ((ele_p+i)-&gt;r_h) = NAN;</span>
<span class="co">    */</span>
  }


  ((ele_p+i)-&gt;ecc) = sqrt((<span class="fl">1.0</span> - r_c[i] / ((ele_p+i)-&gt;axis)) * (<span class="fl">1.0</span> - r_c[i] / ((ele_p+i)-&gt;axis)) + r_dot_v[i] * r_dot_v[i] / mu / ((ele_p+i)-&gt;axis));


  <span class="cf">if</span>(isnan((ele_p+i)-&gt;ecc)){
    fprintf(fplog,<span class="st">&quot;i=%d</span><span class="sc">\t</span><span class="st">ecc is nan.</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
  }


  <span class="cf">if</span>(((ele_p+i)-&gt;ecc)==<span class="fl">0.0</span>){
    ((ele_p+i)-&gt;u) = <span class="fl">0.0</span>;
  }<span class="cf">else</span>{
    esin_u = r_dot_v[i] / sqrt(mu * ((ele_p+i)-&gt;axis));
    ecos_u = <span class="fl">1.0</span> - r_c[i] / ((ele_p+i)-&gt;axis);
    radian = atan2(esin_u,ecos_u);
    <span class="cf">if</span>(radian&lt;<span class="fl">0.0</span>){
      ((ele_p+i)-&gt;u) = radian + <span class="fl">2.0</span> * M_PI;
    }<span class="cf">else</span>{
      ((ele_p+i)-&gt;u) = radian;
    }
  }


  <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){

    P[i][k] = x_c[i][k] * cos(((ele_p+i)-&gt;u)) / r_c[i] - sqrt(((ele_p+i)-&gt;axis) / mu) * v_c[i][k] * sin(((ele_p+i)-&gt;u));
    Q[i][k] = (x_c[i][k] * sin(((ele_p+i)-&gt;u)) / r_c[i] + sqrt(((ele_p+i)-&gt;axis) / mu) * v_c[i][k] * (cos(((ele_p+i)-&gt;u)) - ((ele_p+i)-&gt;ecc))) / sqrt(<span class="fl">1.0</span> - ((ele_p+i)-&gt;ecc));
  }


  <span class="cf">if</span>(isnan(P[i][<span class="dv">1</span>])||isnan(P[i][<span class="dv">2</span>])||isnan(P[i][<span class="dv">3</span>])){
    fprintf(fplog,<span class="st">&quot;i=%d</span><span class="sc">\t</span><span class="st">P is nan.</span><span class="sc">\t</span><span class="st">[1]=%f</span><span class="sc">\t</span><span class="st">[2]=%f</span><span class="sc">\t</span><span class="st">[3]=%f</span><span class="sc">\n</span><span class="st">&quot;</span>,i,P[i][<span class="dv">1</span>],P[i][<span class="dv">2</span>],P[i][<span class="dv">3</span>]);
  }
  <span class="cf">if</span>(isnan(Q[i][<span class="dv">1</span>])||isnan(Q[i][<span class="dv">2</span>])||isnan(Q[i][<span class="dv">3</span>])){
    fprintf(fplog,<span class="st">&quot;i=%d</span><span class="sc">\t</span><span class="st">Q is nan.</span><span class="sc">\t</span><span class="st">[1]=%f</span><span class="sc">\t</span><span class="st">[2]=%f</span><span class="sc">\t</span><span class="st">[3]=%f</span><span class="sc">\n</span><span class="st">&quot;</span>,i,Q[i][<span class="dv">1</span>],Q[i][<span class="dv">2</span>],Q[i][<span class="dv">3</span>]);
  }


  sin_inc = sqrt(P[i][<span class="dv">3</span>] * P[i][<span class="dv">3</span>] + Q[i][<span class="dv">3</span>] * Q[i][<span class="dv">3</span>]);
  cos_inc = P[i][<span class="dv">1</span>] * Q[i][<span class="dv">2</span>] - P[i][<span class="dv">2</span>] * Q[i][<span class="dv">1</span>];
  radian = atan2(sin_inc,cos_inc);


  <span class="cf">if</span>(radian&lt;<span class="fl">0.0</span>){
    ((ele_p+i)-&gt;inc) = radian + <span class="fl">2.0</span> * M_PI;
  }<span class="cf">else</span>{
    ((ele_p+i)-&gt;inc) = radian;
  }


  sin_omega = P[i][<span class="dv">3</span>] / sin_inc;
  cos_omega = Q[i][<span class="dv">3</span>] / sin_inc;
  radian = atan2(sin_omega,cos_omega);
  <span class="cf">if</span>(radian&lt;<span class="fl">0.0</span>){
    ((ele_p+i)-&gt;omega) = radian + <span class="fl">2.0</span>*M_PI;
  }<span class="cf">else</span>{
    ((ele_p+i)-&gt;omega) = radian;
  }


  sin_Omega = (P[i][<span class="dv">2</span>] * Q[i][<span class="dv">3</span>] - Q[i][<span class="dv">2</span>] * P[i][<span class="dv">3</span>]) / sin_inc;
  cos_Omega = (P[i][<span class="dv">1</span>] * Q[i][<span class="dv">3</span>] - Q[i][<span class="dv">1</span>] * P[i][<span class="dv">3</span>]) / sin_inc;
  radian = atan2(sin_Omega,cos_Omega);
  <span class="cf">if</span>(radian&lt;<span class="fl">0.0</span>){
    ((ele_p+i)-&gt;Omega) = radian + <span class="fl">2.0</span> * M_PI;
  }<span class="cf">else</span>{
    ((ele_p+i)-&gt;Omega) = radian;
  }


  <span class="cf">if</span>(sin_inc==<span class="fl">0.0</span>){
    ((ele_p+i)-&gt;omega) = <span class="fl">0.0</span>;
    ((ele_p+i)-&gt;Omega) = <span class="fl">0.0</span>;
  }


<span class="pp">#ifndef M_0</span>
  ((ele_p+i)-&gt;r_h) = ((ele_p+i)-&gt;axis) * cbrt(m_i / <span class="fl">3.0</span>);
<span class="pp">#else</span>
  ((ele_p+i)-&gt;r_h) = ((ele_p+i)-&gt;axis) * cbrt(m_i / M_0 / <span class="fl">3.0</span>);
<span class="pp">#endif</span>


  <span class="cf">if</span>(isnan((ele_p+i)-&gt;inc)){
    fprintf(fplog,<span class="st">&quot;i=%d</span><span class="sc">\t</span><span class="st">inc is nan.</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
  }
  <span class="cf">if</span>(isnan((ele_p+i)-&gt;omega)){
    fprintf(fplog,<span class="st">&quot;i=%d</span><span class="sc">\t</span><span class="st">omega is nan.</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
  }
  <span class="cf">if</span>(isnan((ele_p+i)-&gt;Omega)){
    fprintf(fplog,<span class="st">&quot;i=%d</span><span class="sc">\t</span><span class="st">Omega is nan.</span><span class="sc">\n</span><span class="st">&quot;</span>,i);
  }


  <span class="cf">return</span>;
}</code></pre></div>
<p>位置と速度から接触軌道要素の計算。</p>
<ol type="1">
<li>i i 粒子。</li>
<li>x_c[][4] 位置の修正子。</li>
<li>v_c[][4] 速度の修正子。</li>
<li>*ele_p 軌道要素の構造体ポインタ。</li>
<li>r_c[] 中心星からの距離の修正子。</li>
<li>v2_c[] 速度の大きさの2乗の修正子。</li>
<li>r_dot_v[] 位置ベクトルと速度ベクトルの内積（の修正子）。</li>
<li>t_dyn システム時間。</li>
<li>*frag_p 破壊計算に必要なデータをもつ構造体ポインタ。</li>
</ol>
<p><span class="math inline"><em>μ</em> = <em>G</em>(<em>m</em><sub>1</sub> + <em>m</em><sub>2</sub>) (<em>m</em><sub>1</sub> ≫ <em>m</em><sub>2</sub><em>な</em><em>ら</em><em>μ</em> ≃ <em>G</em><em>m</em><sub>1</sub>)</span></p>
<p><span class="math inline"><em>R</em><sup>2</sup> = <em>X</em><sup>2</sup> + <em>Y</em><sup>2</sup> + <em>Z</em><sup>2</sup></span></p>
<p><span class="math inline">$\dot{R}^2 = \dot{X}^2 + \dot{Y}^2 + \dot{Z}^2$</span></p>
<p><span class="math inline">$R \cdot \dot{R} = X \dot{X} + Y \dot{Y} + Z \dot{Z}$</span></p>
<p>また、<span class="math inline"><em>P</em><sub><em>i</em></sub>, <em>Q</em><sub><em>i</em></sub>(<em>i</em> = <em>x</em>, <em>y</em>, <em>z</em>)</span>を位置と速度で表すと、</p>
<p><span class="math inline">$P_{i}=\frac{X_{i}}{R} \cos E-\sqrt{\frac{a}{\mu}} \dot{X}_{i} \sin E$</span></p>
<p><span class="math inline">$Q_{i}=\frac{1}{\sqrt{1-e^{2}}}\left(\frac{X_{i}}{R} \sin E+\sqrt{\frac{a}{\mu}} \dot{X}_{i}(\cos E-e)\right)$</span></p>
<p>軌道長半径は <span class="math inline">$a=\left(\frac{2}{R}-\frac{V^{2}}{\mu}\right)^{-1}$</span></p>
<p>離心率は <span class="math inline">$e=\sqrt{\left(1-\frac{R}{a}\right)^{2}+\frac{(\boldsymbol{R} \cdot \dot{\boldsymbol{R}})^{2}}{\mu a}}$</span></p>
<p>離心近点離角は <span class="math inline">$\cos E=\frac{1}{e}\left(1-\frac{R}{a}\right) \quad \text { and } \quad \sin E=\frac{\boldsymbol{R} \cdot \dot{\boldsymbol{R}}}{e \sqrt{\mu a}}$</span></p>
<p>軌道傾斜角は <span class="math inline">$\sin I=\sqrt{P_{z}^{2}+Q_{z}^{2}} \quad \text { and } \quad \cos I=P_{x} Q_{y}-P_{y} Q_{x}$</span></p>
<p>近点引数は <span class="math inline">$\sin \omega=\frac{P_{z}}{\sqrt{P_{z}^{2}+Q_{z}^{2}}} \quad \text { and } \quad \cos \omega=\frac{Q_{z}}{\sqrt{P_{z}^{2}+Q_{z}^{2}}}$</span></p>
<p>昇交点経度は <span class="math inline">$\sin \Omega=\frac{P_{y} Q_{z}-Q_{y} P_{z}}{\sqrt{P_{z}^{2}+Q_{z}^{2}}} \quad \text { and } \quad \cos \Omega=\frac{P_{x} Q_{z}-Q_{x} P_{z}}{\sqrt{P_{z}^{2}+Q_{z}^{2}}}$</span></p>
<div class="sourceCode"><pre class="sourceCode c:orbitlal_elements.c"><code class="sourceCode c"><span class="dt">void</span> Calculate_RMS(CONST <span class="kw">struct</span> orbital_elements *ele_p, <span class="dt">double</span> *ecc_p_rms, <span class="dt">double</span> *ecc_tr_rms, <span class="dt">double</span> *inc_p_rms, <span class="dt">double</span> *inc_tr_rms){

  <span class="dt">int</span> i;
  <span class="dt">double</span> ecc_2, ecc_2_mean, inc_2, inc_2_mean;

  ecc_2 = <span class="fl">0.0</span>;
  inc_2 = <span class="fl">0.0</span>;
  <span class="cf">for</span>(i=<span class="dv">1</span>;i&lt;=global_n_p;++i){
    ecc_2 += ((ele_p+i)-&gt;ecc) * ((ele_p+i)-&gt;ecc);
    inc_2 += ((ele_p+i)-&gt;inc) * ((ele_p+i)-&gt;inc);
  }
  ecc_2_mean = ecc_2 / ((<span class="dt">double</span>)global_n_p);
  inc_2_mean = inc_2 / ((<span class="dt">double</span>)global_n_p);
  *ecc_p_rms = sqrt(ecc_2_mean);
  *inc_p_rms = sqrt(inc_2_mean);


  ecc_2 = <span class="fl">0.0</span>;
  inc_2 = <span class="fl">0.0</span>;
  <span class="cf">for</span>(i=global_n_p+<span class="dv">1</span>;i&lt;=global_n;++i){
    ecc_2 += ((ele_p+i)-&gt;ecc) * ((ele_p+i)-&gt;ecc);
    inc_2 += ((ele_p+i)-&gt;inc) * ((ele_p+i)-&gt;inc);
  }
  ecc_2_mean = ecc_2 / ((<span class="dt">double</span>)(global_n-global_n_p));
  inc_2_mean = inc_2 / ((<span class="dt">double</span>)(global_n-global_n_p));
  *ecc_tr_rms = sqrt(ecc_2_mean);
  *inc_tr_rms = sqrt(inc_2_mean);

  <span class="cf">return</span>;
}</code></pre></div>
<p>離心率と軌道傾斜角の2乗平均平方根を計算。</p>
<ol type="1">
<li>*ele_p 軌道要素の構造体ポインタ。</li>
<li>*ecc_p_rms 惑星の離心率の2乗平均平方根のポインタ。</li>
<li>*ecc_tr_rms トレーサーの離心率の2乗平均平方根のポインタ。</li>
<li>*inc_p_rms 惑星の軌道傾斜角の2乗平均平方根のポインタ。</li>
<li>*inc_tr_rms トレーサーの軌道傾斜角の2乗平均平方根のポインタ。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:orbitlal_elements.c"><code class="sourceCode c"><span class="co">/*初期位置、速度計算*/</span>
<span class="dt">void</span> InitialCondition(<span class="dt">int</span> i, <span class="dt">double</span> x_0[][<span class="dv">4</span>], <span class="dt">double</span> v_0[][<span class="dv">4</span>], <span class="dt">double</span> v2_0[], <span class="dt">double</span> r_dot_v[], <span class="dt">double</span> r_0[], CONST <span class="kw">struct</span> orbital_elements *ele_p){

<span class="pp">#if INDIRECT_TERM</span>

<span class="pp">#if !defined(G) &amp;&amp; !defined(M_0)</span>
  <span class="dt">double</span> mu = <span class="fl">1.0</span> + ((ele_p+i)-&gt;mass);
<span class="pp">#else</span>
  <span class="dt">double</span> mu = G * (M_0 + ((ele_p+i)-&gt;mass));
<span class="pp">#endif</span>

<span class="pp">#else</span>

<span class="pp">#if !defined(G) &amp;&amp; !defined(M_0)</span>
  <span class="dt">double</span> mu = <span class="fl">1.0</span>;
<span class="pp">#else</span>
  <span class="dt">double</span> mu = G * M_0;
<span class="pp">#endif</span>

<span class="pp">#endif</span>

  <span class="dt">int</span> k;
  <span class="dt">static</span> <span class="dt">double</span> P[<span class="dv">4</span>]={},Q[<span class="dv">4</span>]={};


  <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;k++){
    P[k] = Calculate_P(i,k,ele_p);
    Q[k] = Calculate_Q(i,k,ele_p);

    x_0[i][k] = ((ele_p+i)-&gt;axis) * P[k] * (cos(((ele_p+i)-&gt;u)) - ((ele_p+i)-&gt;ecc)) + ((ele_p+i)-&gt;axis) * sqrt(<span class="fl">1.0</span> - ((ele_p+i)-&gt;ecc) * ((ele_p+i)-&gt;ecc)) * Q[k] * sin(((ele_p+i)-&gt;u));
  }
  <span class="co">//fprintf(fplog,&quot;x=%f\ty=%f\tz=%f\n&quot;,x_0[i][1],x_0[i][2],x_0[i][3]);</span>

  r_0[i] = RadiusFromCenter(i,x_0);  <span class="co">//中心星からの距離.</span>


  <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){
    v_0[i][k] = sqrt(mu / ((ele_p+i)-&gt;axis)) / r_0[i] * (- ((ele_p+i)-&gt;axis) * P[k] * sin(((ele_p+i)-&gt;u)) + ((ele_p+i)-&gt;axis) * sqrt(<span class="fl">1.0</span> - ((ele_p+i)-&gt;ecc) * ((ele_p+i)-&gt;ecc)) * Q[k] * cos(((ele_p+i)-&gt;u)));
  }

  r_dot_v[i] = InnerProduct(i,x_0,v_0);  <span class="co">//r_i,v_iの内積.</span>
  v2_0[i] = SquareOfVelocity(i,v_0);  <span class="co">//速度の2乗.</span>
  <span class="co">//fprintf(fplog,&quot;vx=%f\tvy=%f\tvz=%f\n&quot;,v_0[i][1],v_0[i][2],v_0[i][3]);</span>

  <span class="cf">return</span>;
}</code></pre></div>
<p>初期軌道要素から初期位置と初期速度を決める。</p>
<ol type="1">
<li>i 粒子番号。</li>
<li>x_0[][4] 初期位置。</li>
<li>v_0[][4] 初期速度。</li>
<li>v2_0[] 初期速度の大きさの2乗。</li>
<li>r_dot_v[] 初期位置ベクトルと初期速度ベクトルの内積。</li>
<li>r_0[] 初期の中心星からの距離。</li>
<li>*ele_p 軌道要素の構造体ポインタ。</li>
</ol>
<p><span class="math inline">$\boldsymbol { R } = \left( \begin{array} { c } { X } \\ { Y } \\ { Z } \end{array} \right) = \left( \begin{array} { c } { a P _ { x } ( \cos E - e ) + a \sqrt { 1 - e ^ { 2 } } Q _ { x } \sin E } \\ { a P _ { y } ( \cos E - e ) + a \sqrt { 1 - e ^ { 2 } } Q _ { y } \sin E } \\ { a P _ { z } ( \cos E - e ) + a \sqrt { 1 - e ^ { 2 } } Q _ { z } \sin E } \end{array} \right)$</span></p>
<p><span class="math inline">$\boldsymbol { \dot{R} } = \left( \begin{array} { c } { \dot { X } } \\ { \dot { Y } } \\ { \dot { Z } } \end{array} \right) = \sqrt{ \frac{\mu}{a}} \frac {1} { R } \left( \begin{array} { c } { - a P _ { x } \sin E + a \sqrt { 1 - e ^ { 2 } } Q _ { x } \cos E } \\ { - a P _ { y } \sin E + a \sqrt { 1 - e ^ { 2 } } Q _ { y } \cos E } \\ { - a P _ { z } \sin E + a \sqrt { 1 - e ^ { 2 } } Q _ { z } \cos E } \end{array} \right)$</span></p>
<h2 id="sfmt.c-1">SFMT.c</h2>
<p>メルセンヌ・ツイスタ法による乱数生成</p>
<p><code>c: SFMT.c /**  * @file  SFMT.c  * @brief SIMD oriented Fast Mersenne Twister(SFMT)  *  * @author Mutsuo Saito (Hiroshima University)  * @author Makoto Matsumoto (Hiroshima University)  *  * Copyright (C) 2006, 2007 Mutsuo Saito, Makoto Matsumoto and Hiroshima  * University.  * Copyright (C) 2012 Mutsuo Saito, Makoto Matsumoto, Hiroshima  * University and The University of Tokyo.  * Copyright (C) 2013 Mutsuo Saito, Makoto Matsumoto and Hiroshima  * University.  * All rights reserved.  *  * The 3-clause BSD License is applied to this software, see  * LICENSE.txt  */</code></p>
<p>拾い物。</p>
<h2 id="sub.c-1">sub.c</h2>
<p>一行でかけるような細々した関数</p>
<div class="sourceCode"><pre class="sourceCode c:sub.c"><code class="sourceCode c"><span class="dt">double</span> rand_func(){
  <span class="cf">return</span> sfmt_genrand_real2(&amp;sfmt);  <span class="co">//generates a random number on [0,1)-real-interval.</span>
}</code></pre></div>
<p>0以上1未満の実数をランダムで返す関数。</p>
<div class="sourceCode"><pre class="sourceCode c:sub.c"><code class="sourceCode c"><span class="dt">void</span> Rotation_3D_xaxis(<span class="dt">int</span> i, <span class="dt">double</span> x_eject[][<span class="dv">4</span>], <span class="dt">double</span> theta){
  <span class="dt">double</span> tmp_y = x_eject[i][<span class="dv">2</span>];
  <span class="dt">double</span> tmp_z = x_eject[i][<span class="dv">3</span>];
  x_eject[i][<span class="dv">2</span>] = cos(theta) * tmp_y - sin(theta) * tmp_z;
  x_eject[i][<span class="dv">3</span>] = sin(theta) * tmp_y + cos(theta) * tmp_z;
  <span class="cf">return</span>;
}


<span class="dt">void</span> Rotation_3D_yaxis(<span class="dt">int</span> i, <span class="dt">double</span> x_eject[][<span class="dv">4</span>], <span class="dt">double</span> theta){
  <span class="dt">double</span> tmp_x = x_eject[i][<span class="dv">1</span>];
  <span class="dt">double</span> tmp_z = x_eject[i][<span class="dv">3</span>];
  x_eject[i][<span class="dv">1</span>] = cos(theta) * tmp_x + sin(theta) * tmp_z;
  x_eject[i][<span class="dv">3</span>] = - sin(theta) * tmp_x + cos(theta) * tmp_z;
  <span class="cf">return</span>;
}


<span class="dt">void</span> Rotation_3D_zaxis(<span class="dt">int</span> i,<span class="dt">double</span> x_eject[][<span class="dv">4</span>],<span class="dt">double</span> theta){
  <span class="dt">double</span> tmp_x = x_eject[i][<span class="dv">1</span>];
  <span class="dt">double</span> tmp_y = x_eject[i][<span class="dv">2</span>];
  x_eject[i][<span class="dv">1</span>] = cos(theta) * tmp_x - sin(theta) * tmp_y;
  x_eject[i][<span class="dv">2</span>] = sin(theta) * tmp_x + cos(theta) * tmp_y;
  <span class="cf">return</span>;
}</code></pre></div>
<p>軸周りの回転。</p>
<div class="sourceCode"><pre class="sourceCode c:sub.c"><code class="sourceCode c"><span class="dt">void</span> CenterOfGravity(CONST <span class="dt">double</span> x_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> v_0[][<span class="dv">4</span>], <span class="dt">double</span> x_G[], <span class="dt">double</span> v_G[], CONST <span class="kw">struct</span> orbital_elements *ele_p
<span class="pp">#if FRAGMENTATION</span>
             , <span class="dt">double</span> t_dyn
             , CONST <span class="kw">struct</span> fragmentation *frag_p
<span class="pp">#endif</span>
             ){
  <span class="dt">int</span> i, k;
  <span class="dt">double</span> M;

<span class="pp">#ifndef M_0</span>
  M = <span class="fl">1.0</span>;
<span class="pp">#else</span>
  M = M_0;
<span class="pp">#endif</span>
  <span class="cf">for</span>(i=<span class="dv">1</span>;i&lt;=
<span class="pp">#if INTERACTION_ALL</span>
    global_n
<span class="pp">#else</span>
    global_n_p
<span class="pp">#endif</span>
    ;++i){

<span class="pp">#if FRAGMENTATION</span>
    M += MassDepletion(i,((ele_p+i)-&gt;mass),t_dyn,frag_p);
<span class="pp">#else</span>
    M += ((ele_p+i)-&gt;mass);
<span class="pp">#endif</span>
  }

  <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){
    x_G[k] = <span class="fl">0.0</span>;
    v_G[k] = <span class="fl">0.0</span>;
    <span class="cf">for</span>(i=<span class="dv">1</span>;i&lt;=
<span class="pp">#if INTERACTION_ALL</span>
    global_n
<span class="pp">#else</span>
    global_n_p
<span class="pp">#endif</span>
      ;++i){

<span class="pp">#if FRAGMENTATION</span>
      x_G[k] += MassDepletion(i,((ele_p+i)-&gt;mass),t_dyn,frag_p) * x_0[i][k];
      v_G[k] += MassDepletion(i,((ele_p+i)-&gt;mass),t_dyn,frag_p) * v_0[i][k];
<span class="pp">#else</span>
      x_G[k] += ((ele_p+i)-&gt;mass) * x_0[i][k];
      v_G[k] += ((ele_p+i)-&gt;mass) * v_0[i][k];
<span class="pp">#endif</span>
    }
    x_G[k] = x_G[k] / M;
    v_G[k] = v_G[k] / M;
  }

  <span class="cf">return</span>;
}</code></pre></div>
<p>重心計算。</p>
<ol type="1">
<li>x_0[][4] 位置。</li>
<li>v_0[][4] 速度。</li>
<li>x_G[] 重心位置。</li>
<li>v_G[] 重心速度。</li>
<li>*ele_p 軌道要素の構造体ポインタ。</li>
<li>t_dyn システム時間。</li>
<li>*frag_p 破壊計算に必要なデータをもつ構造体ポインタ。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:sub.c"><code class="sourceCode c"><span class="dt">double</span> MutualHillRadius_to_SemimajorAxis(<span class="dt">double</span> ratio){
  <span class="cf">return</span> (<span class="fl">1.0</span> / ratio + <span class="fl">0.5</span> * cbrt(<span class="fl">2.0</span> * PLANET_MASS / <span class="fl">3.0</span>)) / (<span class="fl">1.0</span> / ratio - <span class="fl">0.5</span> * cbrt(<span class="fl">2.0</span> * PLANET_MASS / <span class="fl">3.0</span>));
}</code></pre></div>
<p>相互ヒル半径を用いて軌道間隔を設定するときに使う関数。</p>
<p><span class="math inline">$R_{\mathrm{H}, \mathrm{M}}^{i, i+1}=\frac{a_{i}+a_{i+1}}{2}\left(\frac{m_{i}+m_{i+1}}{3 \mathrm{M}_{\odot}}\right)^{1 / 3}$</span></p>
<p>と</p>
<p><span class="math inline"><em>a</em><sub><em>i</em> + 1</sub> − <em>a</em><sub><em>i</em></sub> = <em>b</em><em>R</em><sub><em>H</em>, <em>M</em></sub><sup><em>i</em>, <em>i</em> + 1</sup></span></p>
<p>を連立させて解くと、</p>
<p><span class="math inline"><em>a</em><sub><em>i</em> + 1</sub> = <em>Γ</em>(<em>b</em>,<em>m</em><sub><em>i</em></sub>,<em>m</em><sub><em>i</em> + 1</sub>)<em>a</em><sub><em>i</em></sub></span></p>
<p><span class="math inline">$\Gamma\left(b, m_{i}, m_{i+1}\right) \equiv \frac{\frac{1}{b}+\frac{1}{2}\left(\frac{m_{i}+m_{i+1}}{3 M_{\odot}}\right)^{1 / 3}}{\frac{1}{b}-\frac{1}{2}\left(\frac{m_{i}+m_{i+1}}{3 M_{\odot}}\right)^{1 / 3}}$</span></p>
<p>のような数列のようにかける。</p>
<ol type="1">
<li>ratio 相互ヒル半径の何倍か。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:sub.c"><code class="sourceCode c"><span class="dt">double</span> Escape_Velocity(<span class="dt">double</span> mass_p, <span class="dt">double</span> r){
<span class="pp">#ifndef G</span>
  <span class="cf">return</span> sqrt(<span class="fl">2.0</span> * mass_p / r);
<span class="pp">#else</span>
  <span class="cf">return</span> sqrt(<span class="fl">2.0</span> * G * mass_p / r);
<span class="pp">#endif</span>
}</code></pre></div>
<p>脱出速度。</p>
<ol type="1">
<li>mass_p 天体の質量。</li>
<li>r 天体の半径。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:sub.c"><code class="sourceCode c"><span class="pp">#if EXECUTION_TIME</span>
<span class="dt">void</span> Sort_Exetime(<span class="kw">struct</span> timeval realtime_start_main, <span class="kw">struct</span> timeval realtime_end_main){

  <span class="dt">int</span> i,j;
  <span class="dt">double</span> exetime_main = Cal_time(realtime_start_main,realtime_end_main);
  <span class="dt">int</span> exetime_num[<span class="dv">7</span>]={<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>};

  <span class="dt">double</span> exetime_array[<span class="dv">7</span>]={
    exetime.Energy[<span class="dv">0</span>],
    exetime.Orbital_Elements[<span class="dv">0</span>],
    exetime.Predictor[<span class="dv">0</span>],
    exetime.Corrector[<span class="dv">0</span>],
    exetime.Iteration[<span class="dv">0</span>],
    exetime.Collision_Judgement[<span class="dv">0</span>],
    exetime.Fragmentation[<span class="dv">0</span>]
  };


<span class="pp">#if EXECUTION_TIME_FUNC</span>
  <span class="dt">double</span> exetime_others = <span class="fl">0.0</span>;

  <span class="dt">char</span> exetime_name[<span class="dv">7</span>][<span class="dv">30</span>]={
    <span class="st">&quot;Energy</span><span class="sc">\t\t\t</span><span class="st">&quot;</span>,
    <span class="st">&quot;Orbital_Elements</span><span class="sc">\t</span><span class="st">&quot;</span>,
    <span class="st">&quot;Predictor</span><span class="sc">\t\t</span><span class="st">&quot;</span>,
    <span class="st">&quot;Corrector</span><span class="sc">\t\t</span><span class="st">&quot;</span>,
    <span class="st">&quot;Iteration</span><span class="sc">\t\t</span><span class="st">&quot;</span>,
    <span class="st">&quot;Collision_Judgement</span><span class="sc">\t</span><span class="st">&quot;</span>,
    <span class="st">&quot;Fragmentation</span><span class="sc">\t\t</span><span class="st">&quot;</span>
  };
<span class="pp">#endif</span>

  <span class="cf">for</span>(i=<span class="dv">0</span>;i&lt;<span class="dv">7</span>;++i){
    <span class="cf">for</span>(j=i+<span class="dv">1</span>;j&lt;<span class="dv">7</span>;++j){
      <span class="cf">if</span>(exetime_array[i] &lt; exetime_array[j]){
    Swap_int(&amp;exetime_num[i],&amp;exetime_num[j]);
    Swap_double(&amp;exetime_array[i],&amp;exetime_array[j]);
      }
    }
  }

  fprintf(fplog,<span class="st">&quot;Execution Time</span><span class="sc">\t</span><span class="st">(total</span><span class="sc">\t</span><span class="st">= %e [s])</span><span class="sc">\n</span><span class="st">&quot;</span>,exetime_main);

<span class="pp">#if EXECUTION_TIME_FUNC</span>
  <span class="cf">for</span>(i=<span class="dv">0</span>;i&lt;<span class="dv">7</span>;++i){
    fprintf(fplog,<span class="st">&quot;%s= %e [s]</span><span class="sc">\t</span><span class="st">%5.2f [%%]</span><span class="sc">\n</span><span class="st">&quot;</span>,exetime_name[exetime_num[i]],exetime_array[i],exetime_array[i]/exetime_main*<span class="fl">100.0</span>);
    exetime_others += exetime_array[i];
  }
  exetime_others = exetime_main - exetime_others;
  fprintf(fplog,<span class="st">&quot;Others</span><span class="sc">\t\t\t</span><span class="st">= %e [s]</span><span class="sc">\t</span><span class="st">%5.2f [%%]</span><span class="sc">\n</span><span class="st">&quot;</span>,exetime_others,exetime_others/exetime_main*<span class="fl">100.0</span>);
<span class="pp">#endif</span>

  <span class="cf">return</span>;
}
<span class="pp">#endif</span></code></pre></div>
<p>関数ごとに計測した実行時間を、長い順に並べる関数。</p>
<ol type="1">
<li>realtime_start_main main関数の実行開始時刻。</li>
<li>realtime_end_main main関数の実行終了時刻。</li>
</ol>
<h2 id="timestep.c-1">timestep.c</h2>
<p>タイムステップ計算</p>
<div class="sourceCode"><pre class="sourceCode c:timestep.c"><code class="sourceCode c"><span class="co">/*初期 タイムステップ計算*/</span>
<span class="dt">double</span> Timestep_i_0(<span class="dt">int</span> i, CONST <span class="dt">double</span> a_0[][<span class="dv">4</span>], CONST <span class="dt">double</span> adot_0[][<span class="dv">4</span>]){
  <span class="dt">int</span> k;
  <span class="dt">double</span> abs_a = <span class="fl">0.0</span>;
  <span class="dt">double</span> abs_adot = <span class="fl">0.0</span>;

  <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){
    abs_a += a_0[i][k] * a_0[i][k];
    abs_adot += adot_0[i][k] * adot_0[i][k];
  }  <span class="co">//k loop</span>

  abs_a = sqrt(abs_a);
  abs_adot = sqrt(abs_adot);

  <span class="co">//fprintf(fplog,&quot;abs_a[%d]=%f\tabs_adot[%d]=%f\n&quot;,i,abs_a[i],i,abs_adot[i]);</span>
  <span class="cf">return</span> ETA * abs_a / abs_adot;
}</code></pre></div>
<p>加速度の2階、3階微分を求めることができない、初期用のタイムステップ。 衝突合体の後も使う。</p>
<ol type="1">
<li>i 粒子番号。</li>
<li>a_0[][4] 加速度。</li>
<li>adot_0[][4] 加加速度。</li>
</ol>
<div class="sourceCode"><pre class="sourceCode c:timestep.c"><code class="sourceCode c"><span class="co">/*i_sys のみのタイムステップ計算*/</span>
<span class="dt">double</span> Timestep_i_sys(<span class="dt">int</span> i_sys, CONST <span class="dt">double</span> a[][<span class="dv">4</span>], CONST <span class="dt">double</span> adot[][<span class="dv">4</span>], CONST <span class="dt">double</span> adot2_dt2[][<span class="dv">4</span>], CONST <span class="dt">double</span> adot3_dt3[][<span class="dv">4</span>], CONST <span class="dt">double</span> dt_[]){

  <span class="dt">int</span> k;
  <span class="dt">double</span> dt_inv = <span class="fl">1.0</span> / dt_[i_sys];

  <span class="dt">double</span> abs_a = <span class="fl">0.0</span>;
  <span class="dt">double</span> abs_adot = <span class="fl">0.0</span>;
  <span class="dt">double</span> abs_adot2 = <span class="fl">0.0</span>;
  <span class="dt">double</span> abs_adot3 = <span class="fl">0.0</span>;
  <span class="cf">for</span>(k=<span class="dv">1</span>;k&lt;=<span class="dv">3</span>;++k){
    abs_a += a[i_sys][k] * a[i_sys][k];
    abs_adot += adot[i_sys][k] * adot[i_sys][k];
    abs_adot2 += (adot2_dt2[i_sys][k] + adot3_dt3[i_sys][k])*(adot2_dt2[i_sys][k] + adot3_dt3[i_sys][k]) * dt_inv * dt_inv * dt_inv * dt_inv;
    abs_adot3 += adot3_dt3[i_sys][k] * adot3_dt3[i_sys][k] * dt_inv * dt_inv * dt_inv * dt_inv * dt_inv * dt_inv;
  }  <span class="co">//k loop</span>
  abs_a = sqrt(abs_a);
  abs_adot = sqrt(abs_adot);
  abs_adot2 = sqrt(abs_adot2);
  abs_adot3 = sqrt(abs_adot3);

  <span class="cf">return</span> ETA * sqrt((abs_a * abs_adot2 + abs_adot * abs_adot) / (abs_adot * abs_adot3 + abs_adot2 * abs_adot2));
}</code></pre></div>
<p>各粒子のタイムステップ計算。</p>
<ol type="1">
<li>i_sys 粒子番号。</li>
<li>a[][4] 加速度。</li>
<li>adot[][4] 加加速度。</li>
<li>adot2_dt2[][4] 加速度の2階微分 × タイムステップの2乗。</li>
<li>adot3_dt3[][4] 加速度の3階微分 × タイムステップの3乗。</li>
<li>dt_[] 各粒子のタイムステップ。</li>
</ol>
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTU3Mzc5NTA5OCwxNDA4NjUzNjE2LDMzMj
g0NzgzOCwtMTQxNzc2OTA1MywtNjg0MDQ4NjYzLDEwNDkzNTUy
NTUsLTk0MDg2NzYxMSwtMjA3MjE2OTM4NywxOTQ4Mzg5MTQ3LC
0xNjI1NTI5NDMwLC0yMTA0MzUzNTgxLDE4NDg3ODQxMzQsMTA3
NDM0NzYxNywxMDk3MDg4NTMsLTEyNjQ1OTM1MjMsMTE3MDIyMz
AwOCwtMTE2NjUyNDc1LDEzNDI3MzkwMzEsNTE5Mzg3MDAxLC0x
NTI5NjczNTZdfQ==
-->
</body>
</html>
